'use strict';
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = 'vendor-chunks/msw';
exports.ids = ['vendor-chunks/msw'];
exports.modules = {
  /***/ '(ssr)/./node_modules/msw/lib/index.js':
    /*!***************************************!*\
  !*** ./node_modules/msw/lib/index.js ***!
  \***************************************/
    /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      eval(
        '\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  SetupApi: () => SetupApi,\n  SetupWorkerApi: () => SetupWorkerApi,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  "100": "Continue",\n  "101": "Switching Protocols",\n  "102": "Processing",\n  "103": "Early Hints",\n  "200": "OK",\n  "201": "Created",\n  "202": "Accepted",\n  "203": "Non-Authoritative Information",\n  "204": "No Content",\n  "205": "Reset Content",\n  "206": "Partial Content",\n  "207": "Multi-Status",\n  "208": "Already Reported",\n  "226": "IM Used",\n  "300": "Multiple Choices",\n  "301": "Moved Permanently",\n  "302": "Found",\n  "303": "See Other",\n  "304": "Not Modified",\n  "305": "Use Proxy",\n  "307": "Temporary Redirect",\n  "308": "Permanent Redirect",\n  "400": "Bad Request",\n  "401": "Unauthorized",\n  "402": "Payment Required",\n  "403": "Forbidden",\n  "404": "Not Found",\n  "405": "Method Not Allowed",\n  "406": "Not Acceptable",\n  "407": "Proxy Authentication Required",\n  "408": "Request Timeout",\n  "409": "Conflict",\n  "410": "Gone",\n  "411": "Length Required",\n  "412": "Precondition Failed",\n  "413": "Payload Too Large",\n  "414": "URI Too Long",\n  "415": "Unsupported Media Type",\n  "416": "Range Not Satisfiable",\n  "417": "Expectation Failed",\n  "418": "I\'m a Teapot",\n  "421": "Misdirected Request",\n  "422": "Unprocessable Entity",\n  "423": "Locked",\n  "424": "Failed Dependency",\n  "425": "Too Early",\n  "426": "Upgrade Required",\n  "428": "Precondition Required",\n  "429": "Too Many Requests",\n  "431": "Request Header Fields Too Large",\n  "451": "Unavailable For Legal Reasons",\n  "500": "Internal Server Error",\n  "501": "Not Implemented",\n  "502": "Bad Gateway",\n  "503": "Service Unavailable",\n  "504": "Gateway Timeout",\n  "505": "HTTP Version Not Supported",\n  "506": "Variant Also Negotiates",\n  "507": "Insufficient Storage",\n  "508": "Loop Detected",\n  "509": "Bandwidth Limit Exceeded",\n  "510": "Not Extended",\n  "511": "Network Authentication Required"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === "string") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(__webpack_require__(/*! cookie */ "(ssr)/./node_modules/cookie/index.js"));\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append("Set-Cookie", serializedCookie);\n    if (typeof document !== "undefined") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === "object" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "application/json");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = __webpack_require__(/*! is-node-process */ "(ssr)/./node_modules/is-node-process/lib/index.js");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === "string") {\n      switch (durationOrMode) {\n        case "infinite": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case "real": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode "${durationOrMode}". Please make sure you provide one of the supported modes ("real", "infinite") or a number to "ctx.delay".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === "undefined") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for "setTimeout" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the "infinite" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = __webpack_require__(/*! is-node-process */ "(ssr)/./node_modules/is-node-process/lib/index.js");\nvar import_headers_polyfill2 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__webpack_require__(/*! node-fetch */ "(ssr)/./node_modules/node-fetch/lib/index.js"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set("x-msw-bypass", "true");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if (["GET", "HEAD"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === "object" || typeof body2 === "number" || typeof body2 === "boolean") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === "string") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "text/plain");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "text/xml");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/internal/checkGlobals.ts\nvar import_outvariant2 = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.js");\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.js");\nvar LIBRARY_PREFIX = "[MSW]";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/checkGlobals.ts\nfunction checkGlobals() {\n  (0, import_outvariant2.invariant)(\n    typeof URL !== "undefined",\n    devUtils.formatMessage(\n      `Global "URL" class is not defined. This likely means that you\'re running MSW in an environment that doesn\'t support all Node.js standard API (e.g. React Native). If that\'s the case, please use an appropriate polyfill for the "URL" class, like "react-native-url-polyfill".`\n    )\n  );\n}\n\n// src/setupWorker/setupWorker.ts\nvar import_outvariant5 = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.js");\nvar import_is_node_process3 = __webpack_require__(/*! is-node-process */ "(ssr)/./node_modules/is-node-process/lib/index.js");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = __webpack_require__(/*! @open-draft/until */ "(ssr)/./node_modules/@open-draft/until/lib/index.js");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = __webpack_require__(/*! @open-draft/until */ "(ssr)/./node_modules/@open-draft/until/lib/index.js");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting\n  ];\n  const relevantStates = allStates.filter((state) => {\n    return state != null;\n  });\n  const worker = relevantStates.find((worker2) => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async (url, options = {}, findWorker) => {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(\n    (registrations) => registrations.filter(\n      (registration) => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)\n    )\n  );\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker\n        ),\n        existingRegistration\n      ];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options);\n      return [\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration\n      ];\n    }\n  );\n  if (error2) {\n    const isWorkerMissing = error2.message.includes("(404)");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || "/", location.href);\n      throw new Error(\n        devUtils.formatMessage(`Failed to register a Service Worker for scope (\'${scopeUrl.href}\') with script (\'${absoluteWorkerUrl}\'): Service Worker script does not exist at the given path.\n\nDid you forget to run "npx msw init <PUBLIC_DIR>"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`)\n      );\n    }\n    throw new Error(\n      devUtils.formatMessage(\n        "Failed to register the Service Worker:\\n\\n%s",\n        error2.message\n      )\n    );\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || "Mocking enabled.";\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    "color:orangered;font-weight:bold;"\n  );\n  console.log(\n    "%cDocumentation: %chttps://mswjs.io/docs",\n    "font-weight:bold",\n    "font-weight:normal"\n  );\n  console.log("Found an issue? https://github.com/mswjs/msw/issues");\n  if (args.workerUrl) {\n    console.log("Worker script URL:", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log("Worker scope:", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send("MOCK_ACTIVATE");\n  await context.events.once("MOCKING_ENABLED");\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.`\n    );\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest2) {\n    const [data2, transfer] = rest2;\n    this.port.postMessage({ type: event, data: data2 }, { transfer });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "NetworkError";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = __webpack_require__(/*! @mswjs/interceptors */ "(ssr)/./node_modules/@mswjs/interceptors/lib/index.js");\nvar import_headers_polyfill5 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(__webpack_require__(/*! cookie */ "(ssr)/./node_modules/cookie/index.js"));\nvar import_cookies = __webpack_require__(/*! @mswjs/cookies */ "(ssr)/./node_modules/@mswjs/cookies/lib/index.js");\nvar import_interceptors = __webpack_require__(/*! @mswjs/interceptors */ "(ssr)/./node_modules/@mswjs/interceptors/lib/index.js");\nvar import_bufferUtils = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js");\nvar import_headers_polyfill4 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(__webpack_require__(/*! cookie */ "(ssr)/./node_modules/cookie/index.js"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === "undefined" || typeof location === "undefined") {\n    return {};\n  }\n  switch (request.credentials) {\n    case "same-origin": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case "include": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get("content-type") || "text/plain";\n  const disposition = headers.get("content-disposition");\n  if (!disposition) {\n    throw new Error(\'"Content-Disposition" header is required.\');\n  }\n  const directives = disposition.split(";").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split("=");\n    acc[name2] = rest2.join("=");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get("content-type");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith("boundary=")).map((s) => s.replace(/^boundary=/, ""))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith("\\r\\n") && chunk.endsWith("\\r\\n")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ""));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split("\\r\\n\\r\\n");\n      const contentBody = rest2.join("\\r\\n\\r\\n");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get("content-type")) == null ? void 0 : _a.toLowerCase()) || "";\n  const hasMultipartContent = contentType.startsWith("multipart/form-data");\n  if (hasMultipartContent && typeof body2 !== "object") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes("json");\n  if (hasJsonContent && typeof body2 !== "object") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || "default";\n    this.destination = init.destination || "";\n    this.integrity = init.integrity || "";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || "cors";\n    this.priority = init.priority || "auto";\n    this.redirect = init.redirect || "follow";\n    this.referrer = init.referrer || "";\n    this.referrerPolicy = init.referrerPolicy || "no-referrer";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this["_body"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, "GET") && body2 === "") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: "Continue",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get("cookie");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = import_cookies.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append("cookie", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || ""),\n    headers\n  });\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = __webpack_require__(/*! @open-draft/until */ "(ssr)/./node_modules/@open-draft/until/lib/index.js");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(__webpack_require__(/*! js-levenshtein */ "(ssr)/./node_modules/js-levenshtein/index.js"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = __webpack_require__(/*! graphql */ "(ssr)/./node_modules/graphql/index.js");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === "OperationDefinition";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key \'${key}\' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(".").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property \'${paths}\' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case "GET": {\n      const query = request.url.searchParams.get("query");\n      const variables = request.url.searchParams.get("variables") || "";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case "POST": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || "") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        \'Failed to intercept a GraphQL request to "%s %s": cannot parse query. See the error message from the parser below.\\n\\n%s\',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return "#69AB32" /* Success */;\n  }\n  if (status2 < 400) {\n    return "#F0BB4B" /* Warning */;\n  }\n  return "#E95F5D" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, "0")).join(":");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = __webpack_require__(/*! path-to-regexp */ "(ssr)/./node_modules/path-to-regexp/dist/index.js");\nvar import_getCleanUrl = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, "http://localhost").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, "");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith("*")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== "undefined" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = "(.*)";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(":") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, "$1\\\\$2").replace(/^([^\\/]+)(:)(?=\\/\\/)/, "$1\\\\$2");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === "string" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\n\n// src/response.ts\nvar import_headers_polyfill7 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: "OK",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new import_headers_polyfill7.Headers({\n          "x-powered-by": "msw"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split("\\n").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, "$1").replace(/^@/, "");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == "function";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */ ((RESTMethods2) => {\n  RESTMethods2["HEAD"] = "HEAD";\n  RESTMethods2["GET"] = "GET";\n  RESTMethods2["POST"] = "POST";\n  RESTMethods2["PUT"] = "PUT";\n  RESTMethods2["PATCH"] = "PATCH";\n  RESTMethods2["OPTIONS"] = "OPTIONS";\n  RESTMethods2["DELETE"] = "DELETE";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request["_body"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for "${method} ${path}". Please match against a path instead and access query parameters in the response resolver function using "req.url.searchParams".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage("%s %s %s (%c%s%c)"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      "color:inherit"\n    );\n    console.log("Request", loggedRequest);\n    console.log("Handler:", this);\n    console.log("Response", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant3 = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.js");\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant3.invariant)(\n    fieldName.trim() !== "",\n    devUtils.formatMessage(\n      "Failed to set a custom field on a GraphQL response: field name cannot be empty."\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== "data",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.data()" instead?\',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== "errors",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.errors()" instead?\',\n      fieldName\n    )\n  );\n  (0, import_outvariant3.invariant)(\n    fieldName !== "extensions",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.extensions()" instead?\',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === "object" && "kind" in value && "definitions" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request["_body"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected "${operationType}", but got "${parsedNode.operationType}").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === "all" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : ""\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== "all") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at "${request.method} ${publicUrl}": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using "graphql.operation()" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === "all" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || "") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage("%s %s (%c%s%c)"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      "color:inherit"\n    );\n    console.log("Request:", loggedRequest);\n    console.log("Handler:", this);\n    console.log("Response:", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === "undefined") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== "string") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join("\\n")}`;\n  }\n  return `Did you mean to request "${handlers[0].info.header}" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = "warn") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : "";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join("\\n\\n");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case "error": {\n        devUtils.error("Error: %s", message);\n        throw new Error(\n          devUtils.formatMessage(\n            \'Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.\'\n          )\n        );\n      }\n      case "warn": {\n        devUtils.warn("Warning: %s", message);\n        break;\n      }\n      case "bypass":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            \'Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.\',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === "function") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, "warn"),\n      error: applyStrategy.bind(null, "error")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = __webpack_require__(/*! @mswjs/cookies */ "(ssr)/./node_modules/@mswjs/cookies/lib/index.js");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add({ ...request, url: request.url.toString() }, response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit("request:start", request);\n  if (request.headers.get("x-msw-bypass") === "true") {\n    emitter.emit("request:end", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit("unhandledException", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit("request:unhandled", request);\n    emitter.emit("request:end", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit("request:end", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit("request:end", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit("request:match", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit("request:end", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.js");\nasync function serializeResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(response2.headers)),\n    body: await response2.clone().text()\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage("NOT_FOUND");\n          },\n          async onMockedResponse(response2, { handler, publicRequest, parsedRequest }) {\n            if (response2.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  \'Failed to construct a mocked response with a "ReadableStream" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.\'\n                )\n              );\n            }\n            const responseInstance = new Response(response2.body, response2);\n            const responseForLogs = responseInstance.clone();\n            const responseBodyBuffer = await responseInstance.arrayBuffer();\n            const responseBody = response2.body == null ? null : responseBodyBuffer;\n            messageChannel.postMessage(\n              "MOCK_RESPONSE",\n              {\n                ...response2,\n                body: responseBody\n              },\n              [responseBodyBuffer]\n            );\n            if (!options.quiet) {\n              context.emitter.once("response:mocked", async () => {\n                handler.log(\n                  publicRequest,\n                  await serializeResponse(responseForLogs),\n                  parsedRequest\n                );\n              });\n            }\n          }\n        }\n      );\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage("NETWORK_ERROR", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for "%s %s":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it\'s strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          (_a = error2.stack) != null ? _a : error2\n        );\n        messageChannel.postMessage("MOCK_RESPONSE", {\n          status: 500,\n          statusText: "Request Handler Error",\n          headers: {\n            "Content-Type": "application/json"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send("INTEGRITY_CHECK_REQUEST");\n  const { payload: actualChecksum } = await context.events.once(\n    "INTEGRITY_CHECK_RESPONSE"\n  );\n  if (actualChecksum !== "3d6b9f06410d179a7f7404d4bf4c3c70") {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${"3d6b9f06410d179a7f7404d4bf4c3c70"}).`\n    );\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = __webpack_require__(/*! @open-draft/until */ "(ssr)/./node_modules/@open-draft/until/lib/index.js");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function(...args) {\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async (...args) => {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const { payload: responseJson } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes("opaque")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get("x-powered-by") === "msw";\n    if (isMockedResponse) {\n      context.emitter.emit("response:mocked", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit("response:bypass", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `Cannot intercept requests on this page because it\'s outside of the worker\'s scope ("${registration.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level ("/") of your application.\n- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`\n    );\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = (context) => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\n        "REQUEST",\n        createRequestListener(context, options)\n      );\n      context.workerChannel.on("RESPONSE", createResponseListener(context));\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker\n      );\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(\n          `Failed to locate the Service Worker registration using a custom "findWorker" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at "%s".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n          options.serviceWorker.url\n        ) : devUtils.formatMessage(\n          `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n          options.serviceWorker.url,\n          location.host\n        );\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, "beforeunload", () => {\n        if (worker.state !== "redundant") {\n          context.workerChannel.send("CLIENT_CLOSED");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(\n        () => requestIntegrityCheck(context, worker)\n      );\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it\'s highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send("KEEPALIVE_REQUEST"),\n        5e3\n      );\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting;\n        if (pendingInstance) {\n          await new Promise((resolve) => {\n            pendingInstance.addEventListener("statechange", () => {\n              if (pendingInstance.state === "activated") {\n                return resolve();\n              }\n            });\n          });\n        }\n        await enableMocking(context, options).catch((error2) => {\n          throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n        });\n        return registration;\n      }\n    );\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(\n    `%c${devUtils.formatMessage("Mocking disabled.")}`,\n    "color:orangered;font-weight:bold;"\n  );\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = (context) => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        \'Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.\'\n      );\n      return;\n    }\n    context.workerChannel.send("MOCK_DEACTIVATE");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({ quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet });\n  };\n};\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: "/mockServiceWorker.js",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: "warn",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors3 = __webpack_require__(/*! @mswjs/interceptors */ "(ssr)/./node_modules/@mswjs/interceptors/lib/index.js");\nvar import_fetch3 = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch */ "(ssr)/./node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js");\nvar import_XMLHttpRequest = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest */ "(ssr)/./node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nfunction createResponseFromIsomorphicResponse(response2) {\n  return new Response(response2.body, {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors3.BatchInterceptor({\n    name: "fallback",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on("request", async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer()\n    });\n    const response2 = await handleRequest(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once("response:mocked", async (response3) => {\n              handler.log(\n                publicRequest,\n                await serializeResponse(response3),\n                parsedRequest\n              );\n            });\n          }\n        }\n      }\n    );\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on("response", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get("x-powered-by") === "msw") {\n      context.emitter.emit("response:mocked", browserResponse, request.id);\n    } else {\n      context.emitter.emit("response:bypass", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options\n    );\n    printStartMessage({\n      message: "Mocking enabled (fallback mode).",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({ quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet });\n  };\n}\n\n// src/SetupApi.ts\nvar import_outvariant4 = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.js");\nvar import_strict_event_emitter = __webpack_require__(/*! strict-event-emitter */ "(ssr)/./node_modules/strict-event-emitter/lib/index.js");\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new import_strict_event_emitter.Emitter();\n    this.publicEmitter = new import_strict_event_emitter.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0, import_outvariant4.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          \'Failed to construct "%s" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.\'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  constructor(...handlers) {\n    super(...handlers);\n    this.startHandler = null;\n    this.stopHandler = null;\n    (0, import_outvariant5.invariant)(\n      !(0, import_is_node_process3.isNodeProcess)(),\n      devUtils.formatMessage(\n        "Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead."\n      )\n    );\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(\n            navigator.serviceWorker,\n            "message",\n            (event) => {\n              if (event.source !== this.context.worker) {\n                return;\n              }\n              const message = event.data;\n              if (!message) {\n                return;\n              }\n              if (message.type === eventType) {\n                callback(event, message);\n              }\n            }\n          );\n        },\n        send: (type) => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({ eventType, target, callback });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: (eventType) => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = (event) => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                "message",\n                handleIncomingMessage\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                "messageerror",\n                reject\n              )\n            );\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind());\n          });\n        }\n      },\n      useFallbackMode: !("serviceWorker" in navigator) || location.protocol === "file:"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start(options = {}) {\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options\n    );\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty("operationType") ? "[graphql]" : "[rest]";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log("Handler:", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler("HEAD" /* HEAD */),\n  get: createRestHandler("GET" /* GET */),\n  post: createRestHandler("POST" /* POST */),\n  put: createRestHandler("PUT" /* PUT */),\n  delete: createRestHandler("DELETE" /* DELETE */),\n  patch: createRestHandler("PATCH" /* PATCH */),\n  options: createRestHandler("OPTIONS" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(\n      operationType,\n      operationName,\n      url,\n      resolver\n    );\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return (resolver) => {\n    return new GraphQLHandler(\n      "all",\n      new RegExp(".*"),\n      url,\n      resolver\n    );\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler("*"),\n  query: createScopedGraphQLHandler("query", "*"),\n  mutation: createScopedGraphQLHandler("mutation", "*")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler("query", url),\n    mutation: createScopedGraphQLHandler("mutation", url)\n  };\n}\nvar graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink\n};\n\n// src/index.ts\ncheckGlobals();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXN3L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRyx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsNEVBQWtCO0FBQ3hE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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBc0JMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtcmVhY3QtY2hha3JhdWkvLi9ub2RlX21vZHVsZXMvbXN3L2xpYi9pbmRleC5qcz8xZDdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBHcmFwaFFMSGFuZGxlcjogKCkgPT4gR3JhcGhRTEhhbmRsZXIsXG4gIE1vY2tlZFJlcXVlc3Q6ICgpID0+IE1vY2tlZFJlcXVlc3QsXG4gIFJFU1RNZXRob2RzOiAoKSA9PiBSRVNUTWV0aG9kcyxcbiAgUmVxdWVzdEhhbmRsZXI6ICgpID0+IFJlcXVlc3RIYW5kbGVyLFxuICBSZXN0SGFuZGxlcjogKCkgPT4gUmVzdEhhbmRsZXIsXG4gIFNldHVwQXBpOiAoKSA9PiBTZXR1cEFwaSxcbiAgU2V0dXBXb3JrZXJBcGk6ICgpID0+IFNldHVwV29ya2VyQXBpLFxuICBjbGVhblVybDogKCkgPT4gY2xlYW5VcmwsXG4gIGNvbXBvc2U6ICgpID0+IGNvbXBvc2UsXG4gIGNvbnRleHQ6ICgpID0+IGNvbnRleHRfZXhwb3J0cyxcbiAgY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbjogKCkgPT4gY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbixcbiAgZGVmYXVsdENvbnRleHQ6ICgpID0+IGRlZmF1bHRDb250ZXh0LFxuICBkZWZhdWx0UmVzcG9uc2U6ICgpID0+IGRlZmF1bHRSZXNwb25zZSxcbiAgZ3JhcGhxbDogKCkgPT4gZ3JhcGhxbCxcbiAgZ3JhcGhxbENvbnRleHQ6ICgpID0+IGdyYXBocWxDb250ZXh0LFxuICBoYW5kbGVSZXF1ZXN0OiAoKSA9PiBoYW5kbGVSZXF1ZXN0LFxuICBtYXRjaFJlcXVlc3RVcmw6ICgpID0+IG1hdGNoUmVxdWVzdFVybCxcbiAgcmVzcG9uc2U6ICgpID0+IHJlc3BvbnNlLFxuICByZXN0OiAoKSA9PiByZXN0LFxuICByZXN0Q29udGV4dDogKCkgPT4gcmVzdENvbnRleHQsXG4gIHNldHVwV29ya2VyOiAoKSA9PiBzZXR1cFdvcmtlclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9jb250ZXh0L2luZGV4LnRzXG52YXIgY29udGV4dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChjb250ZXh0X2V4cG9ydHMsIHtcbiAgYm9keTogKCkgPT4gYm9keSxcbiAgY29va2llOiAoKSA9PiBjb29raWUsXG4gIGRhdGE6ICgpID0+IGRhdGEsXG4gIGRlbGF5OiAoKSA9PiBkZWxheSxcbiAgZXJyb3JzOiAoKSA9PiBlcnJvcnMsXG4gIGV4dGVuc2lvbnM6ICgpID0+IGV4dGVuc2lvbnMsXG4gIGZldGNoOiAoKSA9PiBmZXRjaCxcbiAganNvbjogKCkgPT4ganNvbixcbiAgc2V0OiAoKSA9PiBzZXQsXG4gIHN0YXR1czogKCkgPT4gc3RhdHVzLFxuICB0ZXh0OiAoKSA9PiB0ZXh0LFxuICB4bWw6ICgpID0+IHhtbFxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS9zdGF0dXNlc0AyLjAuMS9ub2RlX21vZHVsZXMvc3RhdHVzZXMvY29kZXMuanNvblxudmFyIGNvZGVzX2RlZmF1bHQgPSB7XG4gIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICBcIjEwM1wiOiBcIkVhcmx5IEhpbnRzXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgVGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJUb28gRWFybHlcIixcbiAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59O1xuXG4vLyBzcmMvY29udGV4dC9zdGF0dXMudHNcbnZhciBzdGF0dXMgPSAoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5zdGF0dXMgPSBzdGF0dXNDb2RlO1xuICAgIHJlcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBjb2Rlc19kZWZhdWx0W1N0cmluZyhzdGF0dXNDb2RlKV07XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3NldC50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5mdW5jdGlvbiBzZXQoLi4uYXJncykge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzLmhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZGVycyA9ICgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbC5vYmplY3RUb0hlYWRlcnMpKG5hbWUpO1xuICAgICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZTIsIG5hbWUyKSA9PiB7XG4gICAgICAgIHJlcy5oZWFkZXJzLmFwcGVuZChuYW1lMiwgdmFsdWUyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vLyBzcmMvY29udGV4dC9jb29raWUudHNcbnZhciBjb29raWVVdGlscyA9IF9fdG9FU00ocmVxdWlyZShcImNvb2tpZVwiKSk7XG52YXIgY29va2llID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZENvb2tpZSA9IGNvb2tpZVV0aWxzLnNlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmVzLmhlYWRlcnMuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBzZXJpYWxpemVkQ29va2llKTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkb2N1bWVudC5jb29raWUgPSBzZXJpYWxpemVkQ29va2llO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvYm9keS50c1xudmFyIGJvZHkgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuYm9keSA9IHZhbHVlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvanNvblBhcnNlLnRzXG5mdW5jdGlvbiBqc29uUGFyc2UodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzT2JqZWN0LnRzXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvbWVyZ2VSaWdodC50c1xuZnVuY3Rpb24gbWVyZ2VSaWdodChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmlnaHQpLnJlZHVjZSgocmVzdWx0LCBba2V5LCByaWdodFZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHJlc3VsdFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnRWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsZWZ0VmFsdWUuY29uY2F0KHJpZ2h0VmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGxlZnRWYWx1ZSkgJiYgaXNPYmplY3QocmlnaHRWYWx1ZSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VSaWdodChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0W2tleV0gPSByaWdodFZhbHVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIE9iamVjdC5hc3NpZ24oe30sIGxlZnQpKTtcbn1cblxuLy8gc3JjL2NvbnRleHQvanNvbi50c1xudmFyIGpzb24gPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIHJlcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keTIpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9kYXRhLnRzXG52YXIgZGF0YSA9IChwYXlsb2FkKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBkYXRhOiBwYXlsb2FkIH0pO1xuICAgIHJldHVybiBqc29uKG5leHRCb2R5KShyZXMpO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXh0ZW5zaW9ucy50c1xudmFyIGV4dGVuc2lvbnMgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZXh0ZW5zaW9uczogcGF5bG9hZCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2RlbGF5LnRzXG52YXIgaW1wb3J0X2lzX25vZGVfcHJvY2VzcyA9IHJlcXVpcmUoXCJpcy1ub2RlLXByb2Nlc3NcIik7XG52YXIgU0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UID0gMjE0NzQ4MzY0NztcbnZhciBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUUgPSAxMDA7XG52YXIgTUFYX1NFUlZFUl9SRVNQT05TRV9USU1FID0gNDAwO1xudmFyIE5PREVfU0VSVkVSX1JFU1BPTlNFX1RJTUUgPSA1O1xudmFyIGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSA9ICgpID0+IHtcbiAgaWYgKCgwLCBpbXBvcnRfaXNfbm9kZV9wcm9jZXNzLmlzTm9kZVByb2Nlc3MpKCkpIHtcbiAgICByZXR1cm4gTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICBNYXRoLnJhbmRvbSgpICogKE1BWF9TRVJWRVJfUkVTUE9OU0VfVElNRSAtIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSkgKyBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUVcbiAgKTtcbn07XG52YXIgZGVsYXkgPSAoZHVyYXRpb25Pck1vZGUpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBsZXQgZGVsYXlUaW1lO1xuICAgIGlmICh0eXBlb2YgZHVyYXRpb25Pck1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN3aXRjaCAoZHVyYXRpb25Pck1vZGUpIHtcbiAgICAgICAgY2FzZSBcImluZmluaXRlXCI6IHtcbiAgICAgICAgICBkZWxheVRpbWUgPSBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlYWxcIjoge1xuICAgICAgICAgIGRlbGF5VGltZSA9IGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGRlbGF5IGEgcmVzcG9uc2U6IHVua25vd24gZGVsYXkgbW9kZSBcIiR7ZHVyYXRpb25Pck1vZGV9XCIuIFBsZWFzZSBtYWtlIHN1cmUgeW91IHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgbW9kZXMgKFwicmVhbFwiLCBcImluZmluaXRlXCIpIG9yIGEgbnVtYmVyIHRvIFwiY3R4LmRlbGF5XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbk9yTW9kZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZGVsYXlUaW1lID0gZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkdXJhdGlvbk9yTW9kZSA+IFNFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBkZWxheSBhIHJlc3BvbnNlOiBwcm92aWRlZCBkZWxheSBkdXJhdGlvbiAoJHtkdXJhdGlvbk9yTW9kZX0pIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBkdXJhdGlvbiBmb3IgXCJzZXRUaW1lb3V0XCIgKCR7U0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UfSkuIFRoaXMgd2lsbCBjYXVzZSB0aGUgcmVzcG9uc2UgdG8gYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHkuIFBsZWFzZSB1c2UgYSBudW1iZXIgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBieSBleGFjdCBkdXJhdGlvbiwgb3IgY29uc2lkZXIgdGhlIFwiaW5maW5pdGVcIiBkZWxheSBtb2RlIHRvIGRlbGF5IHRoZSByZXNwb25zZSBpbmRlZmluaXRlbHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVsYXlUaW1lID0gZHVyYXRpb25Pck1vZGU7XG4gICAgfVxuICAgIHJlcy5kZWxheSA9IGRlbGF5VGltZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZXJyb3JzLnRzXG52YXIgZXJyb3JzID0gKGVycm9yc0xpc3QpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBpZiAoZXJyb3JzTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGVycm9yczogZXJyb3JzTGlzdCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2ZldGNoLnRzXG52YXIgaW1wb3J0X2lzX25vZGVfcHJvY2VzczIgPSByZXF1aXJlKFwiaXMtbm9kZS1wcm9jZXNzXCIpO1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsMiA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xudmFyIHVzZUZldGNoID0gKDAsIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MyLmlzTm9kZVByb2Nlc3MpKCkgPyAoaW5wdXQsIGluaXQpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX190b0VTTShyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSkpLnRoZW4oXG4gICh7IGRlZmF1bHQ6IG5vZGVGZXRjaCB9KSA9PiBub2RlRmV0Y2goaW5wdXQsIGluaXQpXG4pIDogZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBhdWdtZW50UmVxdWVzdEluaXQgPSAocmVxdWVzdEluaXQpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDIuSGVhZGVycyhyZXF1ZXN0SW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJ4LW1zdy1ieXBhc3NcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3RJbml0LFxuICAgIGhlYWRlcnM6IGhlYWRlcnMuYWxsKClcbiAgfTtcbn07XG52YXIgY3JlYXRlRmV0Y2hSZXF1ZXN0UGFyYW1ldGVycyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCB7IGJvZHk6IGJvZHkyLCBtZXRob2QgfSA9IGlucHV0O1xuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IHtcbiAgICAuLi5pbnB1dCxcbiAgICBib2R5OiB2b2lkIDBcbiAgfTtcbiAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIHJldHVybiByZXF1ZXN0UGFyYW1ldGVycztcbiAgfVxuICBpZiAodHlwZW9mIGJvZHkyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBib2R5MiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYm9keTIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmVxdWVzdFBhcmFtZXRlcnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkyKTtcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0UGFyYW1ldGVycy5ib2R5ID0gYm9keTI7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xufTtcbnZhciBmZXRjaCA9IChpbnB1dCwgcmVxdWVzdEluaXQgPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHVzZUZldGNoKGlucHV0LCBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdEluaXQpKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0UGFyYW1ldGVycyA9IGNyZWF0ZUZldGNoUmVxdWVzdFBhcmFtZXRlcnMoaW5wdXQpO1xuICBjb25zdCBkZXJpdmVkUmVxdWVzdEluaXQgPSBhdWdtZW50UmVxdWVzdEluaXQocmVxdWVzdFBhcmFtZXRlcnMpO1xuICByZXR1cm4gdXNlRmV0Y2goaW5wdXQudXJsLmhyZWYsIGRlcml2ZWRSZXF1ZXN0SW5pdCk7XG59O1xuXG4vLyBzcmMvY29udGV4dC90ZXh0LnRzXG52YXIgdGV4dCA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQveG1sLnRzXG52YXIgeG1sID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94bWxcIik7XG4gICAgcmVzLmJvZHkgPSBib2R5MjtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2NoZWNrR2xvYmFscy50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50MiA9IHJlcXVpcmUoXCJvdXR2YXJpYW50XCIpO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvZGV2VXRpbHMudHNcbnZhciBpbXBvcnRfb3V0dmFyaWFudCA9IHJlcXVpcmUoXCJvdXR2YXJpYW50XCIpO1xudmFyIExJQlJBUllfUFJFRklYID0gXCJbTVNXXVwiO1xuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zdCBpbnRlcnBvbGF0ZWRNZXNzYWdlID0gKDAsIGltcG9ydF9vdXR2YXJpYW50LmZvcm1hdCkobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpO1xuICByZXR1cm4gYCR7TElCUkFSWV9QUkVGSVh9ICR7aW50ZXJwb2xhdGVkTWVzc2FnZX1gO1xufVxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLndhcm4oZm9ybWF0TWVzc2FnZShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykpO1xufVxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc29sZS5lcnJvcihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG52YXIgZGV2VXRpbHMgPSB7XG4gIGZvcm1hdE1lc3NhZ2UsXG4gIHdhcm4sXG4gIGVycm9yXG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvY2hlY2tHbG9iYWxzLnRzXG5mdW5jdGlvbiBjaGVja0dsb2JhbHMoKSB7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDIuaW52YXJpYW50KShcbiAgICB0eXBlb2YgVVJMICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBgR2xvYmFsIFwiVVJMXCIgY2xhc3MgaXMgbm90IGRlZmluZWQuIFRoaXMgbGlrZWx5IG1lYW5zIHRoYXQgeW91J3JlIHJ1bm5pbmcgTVNXIGluIGFuIGVudmlyb25tZW50IHRoYXQgZG9lc24ndCBzdXBwb3J0IGFsbCBOb2RlLmpzIHN0YW5kYXJkIEFQSSAoZS5nLiBSZWFjdCBOYXRpdmUpLiBJZiB0aGF0J3MgdGhlIGNhc2UsIHBsZWFzZSB1c2UgYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwgZm9yIHRoZSBcIlVSTFwiIGNsYXNzLCBsaWtlIFwicmVhY3QtbmF0aXZlLXVybC1wb2x5ZmlsbFwiLmBcbiAgICApXG4gICk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zZXR1cFdvcmtlci50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50NSA9IHJlcXVpcmUoXCJvdXR2YXJpYW50XCIpO1xudmFyIGltcG9ydF9pc19ub2RlX3Byb2Nlc3MzID0gcmVxdWlyZShcImlzLW5vZGUtcHJvY2Vzc1wiKTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVN0YXJ0SGFuZGxlci50c1xudmFyIGltcG9ydF91bnRpbDQgPSByZXF1aXJlKFwiQG9wZW4tZHJhZnQvdW50aWxcIik7XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9nZXRXb3JrZXJJbnN0YW5jZS50c1xudmFyIGltcG9ydF91bnRpbCA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L3V0aWxzL2dldFdvcmtlckJ5UmVnaXN0cmF0aW9uLnRzXG5mdW5jdGlvbiBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKSB7XG4gIGNvbnN0IGFsbFN0YXRlcyA9IFtcbiAgICByZWdpc3RyYXRpb24uYWN0aXZlLFxuICAgIHJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nLFxuICAgIHJlZ2lzdHJhdGlvbi53YWl0aW5nXG4gIF07XG4gIGNvbnN0IHJlbGV2YW50U3RhdGVzID0gYWxsU3RhdGVzLmZpbHRlcigoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gc3RhdGUgIT0gbnVsbDtcbiAgfSk7XG4gIGNvbnN0IHdvcmtlciA9IHJlbGV2YW50U3RhdGVzLmZpbmQoKHdvcmtlcjIpID0+IHtcbiAgICByZXR1cm4gZmluZFdvcmtlcih3b3JrZXIyLnNjcmlwdFVSTCwgYWJzb2x1dGVXb3JrZXJVcmwpO1xuICB9KTtcbiAgcmV0dXJuIHdvcmtlciB8fCBudWxsO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsL2dldEFic29sdXRlV29ya2VyVXJsLnRzXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVdvcmtlclVybCh3b3JrZXJVcmwpIHtcbiAgcmV0dXJuIG5ldyBVUkwod29ya2VyVXJsLCBsb2NhdGlvbi5ocmVmKS5ocmVmO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZ2V0V29ya2VySW5zdGFuY2UudHNcbnZhciBnZXRXb3JrZXJJbnN0YW5jZSA9IGFzeW5jICh1cmwsIG9wdGlvbnMgPSB7fSwgZmluZFdvcmtlcikgPT4ge1xuICBjb25zdCBhYnNvbHV0ZVdvcmtlclVybCA9IGdldEFic29sdXRlV29ya2VyVXJsKHVybCk7XG4gIGNvbnN0IG1vY2tSZWdpc3RyYXRpb25zID0gYXdhaXQgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuZ2V0UmVnaXN0cmF0aW9ucygpLnRoZW4oXG4gICAgKHJlZ2lzdHJhdGlvbnMpID0+IHJlZ2lzdHJhdGlvbnMuZmlsdGVyKFxuICAgICAgKHJlZ2lzdHJhdGlvbikgPT4gZ2V0V29ya2VyQnlSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uLCBhYnNvbHV0ZVdvcmtlclVybCwgZmluZFdvcmtlcilcbiAgICApXG4gICk7XG4gIGlmICghbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciAmJiBtb2NrUmVnaXN0cmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbiAgY29uc3QgW2V4aXN0aW5nUmVnaXN0cmF0aW9uXSA9IG1vY2tSZWdpc3RyYXRpb25zO1xuICBpZiAoZXhpc3RpbmdSZWdpc3RyYXRpb24pIHtcbiAgICByZXR1cm4gZXhpc3RpbmdSZWdpc3RyYXRpb24udXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihcbiAgICAgICAgICBleGlzdGluZ1JlZ2lzdHJhdGlvbixcbiAgICAgICAgICBhYnNvbHV0ZVdvcmtlclVybCxcbiAgICAgICAgICBmaW5kV29ya2VyXG4gICAgICAgICksXG4gICAgICAgIGV4aXN0aW5nUmVnaXN0cmF0aW9uXG4gICAgICBdO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IFtlcnJvcjIsIGluc3RhbmNlXSA9IGF3YWl0ICgwLCBpbXBvcnRfdW50aWwudW50aWwpKFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKHVybCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBnZXRXb3JrZXJCeVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGFic29sdXRlV29ya2VyVXJsLCBmaW5kV29ya2VyKSxcbiAgICAgICAgcmVnaXN0cmF0aW9uXG4gICAgICBdO1xuICAgIH1cbiAgKTtcbiAgaWYgKGVycm9yMikge1xuICAgIGNvbnN0IGlzV29ya2VyTWlzc2luZyA9IGVycm9yMi5tZXNzYWdlLmluY2x1ZGVzKFwiKDQwNClcIik7XG4gICAgaWYgKGlzV29ya2VyTWlzc2luZykge1xuICAgICAgY29uc3Qgc2NvcGVVcmwgPSBuZXcgVVJMKChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3BlKSB8fCBcIi9cIiwgbG9jYXRpb24uaHJlZik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoYEZhaWxlZCB0byByZWdpc3RlciBhIFNlcnZpY2UgV29ya2VyIGZvciBzY29wZSAoJyR7c2NvcGVVcmwuaHJlZn0nKSB3aXRoIHNjcmlwdCAoJyR7YWJzb2x1dGVXb3JrZXJVcmx9Jyk6IFNlcnZpY2UgV29ya2VyIHNjcmlwdCBkb2VzIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gcGF0aC5cblxuRGlkIHlvdSBmb3JnZXQgdG8gcnVuIFwibnB4IG1zdyBpbml0IDxQVUJMSUNfRElSPlwiP1xuXG5MZWFybiBtb3JlIGFib3V0IGNyZWF0aW5nIHRoZSBTZXJ2aWNlIFdvcmtlciBzY3JpcHQ6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9jbGkvaW5pdGApXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICBcIkZhaWxlZCB0byByZWdpc3RlciB0aGUgU2VydmljZSBXb3JrZXI6XFxuXFxuJXNcIixcbiAgICAgICAgZXJyb3IyLm1lc3NhZ2VcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9wcmludFN0YXJ0TWVzc2FnZS50c1xuZnVuY3Rpb24gcHJpbnRTdGFydE1lc3NhZ2UoYXJncyA9IHt9KSB7XG4gIGlmIChhcmdzLnF1aWV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBhcmdzLm1lc3NhZ2UgfHwgXCJNb2NraW5nIGVuYWJsZWQuXCI7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgYCVjJHtkZXZVdGlscy5mb3JtYXRNZXNzYWdlKG1lc3NhZ2UpfWAsXG4gICAgXCJjb2xvcjpvcmFuZ2VyZWQ7Zm9udC13ZWlnaHQ6Ym9sZDtcIlxuICApO1xuICBjb25zb2xlLmxvZyhcbiAgICBcIiVjRG9jdW1lbnRhdGlvbjogJWNodHRwczovL21zd2pzLmlvL2RvY3NcIixcbiAgICBcImZvbnQtd2VpZ2h0OmJvbGRcIixcbiAgICBcImZvbnQtd2VpZ2h0Om5vcm1hbFwiXG4gICk7XG4gIGNvbnNvbGUubG9nKFwiRm91bmQgYW4gaXNzdWU/IGh0dHBzOi8vZ2l0aHViLmNvbS9tc3dqcy9tc3cvaXNzdWVzXCIpO1xuICBpZiAoYXJncy53b3JrZXJVcmwpIHtcbiAgICBjb25zb2xlLmxvZyhcIldvcmtlciBzY3JpcHQgVVJMOlwiLCBhcmdzLndvcmtlclVybCk7XG4gIH1cbiAgaWYgKGFyZ3Mud29ya2VyU2NvcGUpIHtcbiAgICBjb25zb2xlLmxvZyhcIldvcmtlciBzY29wZTpcIiwgYXJncy53b3JrZXJTY29wZSk7XG4gIH1cbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvZW5hYmxlTW9ja2luZy50c1xuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTW9ja2luZyhjb250ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiTU9DS19BQ1RJVkFURVwiKTtcbiAgYXdhaXQgY29udGV4dC5ldmVudHMub25jZShcIk1PQ0tJTkdfRU5BQkxFRFwiKTtcbiAgaWYgKGNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCkge1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRm91bmQgYSByZWR1bmRhbnQgXCJ3b3JrZXIuc3RhcnQoKVwiIGNhbGwuIE5vdGUgdGhhdCBzdGFydGluZyB0aGUgd29ya2VyIHdoaWxlIG1vY2tpbmcgaXMgYWxyZWFkeSBlbmFibGVkIHdpbGwgaGF2ZSBubyBlZmZlY3QuIENvbnNpZGVyIHJlbW92aW5nIHRoaXMgXCJ3b3JrZXIuc3RhcnQoKVwiIGNhbGwuYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCA9IHRydWU7XG4gIHByaW50U3RhcnRNZXNzYWdlKHtcbiAgICBxdWlldDogb3B0aW9ucy5xdWlldCxcbiAgICB3b3JrZXJTY29wZTogKF9hID0gY29udGV4dC5yZWdpc3RyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY29wZSxcbiAgICB3b3JrZXJVcmw6IChfYiA9IGNvbnRleHQud29ya2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2NyaXB0VVJMXG4gIH0pO1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvY3JlYXRlTWVzc2FnZUNoYW5uZWwudHNcbnZhciBXb3JrZXJDaGFubmVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgfVxuICBwb3N0TWVzc2FnZShldmVudCwgLi4ucmVzdDIpIHtcbiAgICBjb25zdCBbZGF0YTIsIHRyYW5zZmVyXSA9IHJlc3QyO1xuICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7IHR5cGU6IGV2ZW50LCBkYXRhOiBkYXRhMiB9LCB7IHRyYW5zZmVyIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvTmV0d29ya0Vycm9yLnRzXG52YXIgTmV0d29ya0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIk5ldHdvcmtFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9wYXJzZVdvcmtlclJlcXVlc3QudHNcbnZhciBpbXBvcnRfaW50ZXJjZXB0b3JzMiA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzXCIpO1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNSA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9Nb2NrZWRSZXF1ZXN0LnRzXG52YXIgY29va2llVXRpbHMzID0gX190b0VTTShyZXF1aXJlKFwiY29va2llXCIpKTtcbnZhciBpbXBvcnRfY29va2llcyA9IHJlcXVpcmUoXCJAbXN3anMvY29va2llc1wiKTtcbnZhciBpbXBvcnRfaW50ZXJjZXB0b3JzID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIik7XG52YXIgaW1wb3J0X2J1ZmZlclV0aWxzID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL3V0aWxzL2J1ZmZlclV0aWxzLmpzXCIpO1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNCA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9nZXRSZXF1ZXN0Q29va2llcy50c1xudmFyIGNvb2tpZVV0aWxzMiA9IF9fdG9FU00ocmVxdWlyZShcImNvb2tpZVwiKSk7XG5mdW5jdGlvbiBnZXRBbGxDb29raWVzKCkge1xuICByZXR1cm4gY29va2llVXRpbHMyLnBhcnNlKGRvY3VtZW50LmNvb2tpZSk7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0Q29va2llcyhyZXF1ZXN0KSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGxvY2F0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN3aXRjaCAocmVxdWVzdC5jcmVkZW50aWFscykge1xuICAgIGNhc2UgXCJzYW1lLW9yaWdpblwiOiB7XG4gICAgICByZXR1cm4gbG9jYXRpb24ub3JpZ2luID09PSByZXF1ZXN0LnVybC5vcmlnaW4gPyBnZXRBbGxDb29raWVzKCkgOiB7fTtcbiAgICB9XG4gICAgY2FzZSBcImluY2x1ZGVcIjoge1xuICAgICAgcmV0dXJuIGdldEFsbENvb2tpZXMoKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VNdWx0aXBhcnREYXRhLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGwzID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5mdW5jdGlvbiBwYXJzZUNvbnRlbnRIZWFkZXJzKGhlYWRlcnNTdHJpbmcpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgaGVhZGVycyA9ICgwLCBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDMuc3RyaW5nVG9IZWFkZXJzKShoZWFkZXJzU3RyaW5nKTtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcInRleHQvcGxhaW5cIjtcbiAgY29uc3QgZGlzcG9zaXRpb24gPSBoZWFkZXJzLmdldChcImNvbnRlbnQtZGlzcG9zaXRpb25cIik7XG4gIGlmICghZGlzcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQ29udGVudC1EaXNwb3NpdGlvblwiIGhlYWRlciBpcyByZXF1aXJlZC4nKTtcbiAgfVxuICBjb25zdCBkaXJlY3RpdmVzID0gZGlzcG9zaXRpb24uc3BsaXQoXCI7XCIpLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4ge1xuICAgIGNvbnN0IFtuYW1lMiwgLi4ucmVzdDJdID0gY2h1bmsudHJpbSgpLnNwbGl0KFwiPVwiKTtcbiAgICBhY2NbbmFtZTJdID0gcmVzdDIuam9pbihcIj1cIik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBjb25zdCBuYW1lID0gKF9hID0gZGlyZWN0aXZlcy5uYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2xpY2UoMSwgLTEpO1xuICBjb25zdCBmaWxlbmFtZSA9IChfYiA9IGRpcmVjdGl2ZXMuZmlsZW5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zbGljZSgxLCAtMSk7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBmaWxlbmFtZSxcbiAgICBjb250ZW50VHlwZVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VNdWx0aXBhcnREYXRhKGRhdGEyLCBoZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gIGlmICghY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFssIC4uLmRpcmVjdGl2ZXNdID0gY29udGVudFR5cGUuc3BsaXQoLzsgKi8pO1xuICBjb25zdCBib3VuZGFyeSA9IGRpcmVjdGl2ZXMuZmlsdGVyKChkKSA9PiBkLnN0YXJ0c1dpdGgoXCJib3VuZGFyeT1cIikpLm1hcCgocykgPT4gcy5yZXBsYWNlKC9eYm91bmRhcnk9LywgXCJcIikpWzBdO1xuICBpZiAoIWJvdW5kYXJ5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBib3VuZGFyeVJlZ0V4cCA9IG5ldyBSZWdFeHAoYC0tKyR7Ym91bmRhcnl9YCk7XG4gIGNvbnN0IGZpZWxkcyA9IGRhdGEyLnNwbGl0KGJvdW5kYXJ5UmVnRXhwKS5maWx0ZXIoKGNodW5rKSA9PiBjaHVuay5zdGFydHNXaXRoKFwiXFxyXFxuXCIpICYmIGNodW5rLmVuZHNXaXRoKFwiXFxyXFxuXCIpKS5tYXAoKGNodW5rKSA9PiBjaHVuay50cmltU3RhcnQoKS5yZXBsYWNlKC9cXHJcXG4kLywgXCJcIikpO1xuICBpZiAoIWZpZWxkcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHBhcnNlZEJvZHkgPSB7fTtcbiAgdHJ5IHtcbiAgICBmb3IgKGNvbnN0IGZpZWxkMiBvZiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IFtjb250ZW50SGVhZGVycywgLi4ucmVzdDJdID0gZmllbGQyLnNwbGl0KFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgY29uc3QgY29udGVudEJvZHkgPSByZXN0Mi5qb2luKFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgY29uc3QgeyBjb250ZW50VHlwZTogY29udGVudFR5cGUyLCBmaWxlbmFtZSwgbmFtZSB9ID0gcGFyc2VDb250ZW50SGVhZGVycyhjb250ZW50SGVhZGVycyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpbGVuYW1lID09PSB2b2lkIDAgPyBjb250ZW50Qm9keSA6IG5ldyBGaWxlKFtjb250ZW50Qm9keV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlMiB9KTtcbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkQm9keVtuYW1lXTtcbiAgICAgIGlmIChwYXJzZWRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFsuLi5wYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keVtuYW1lXSA9IFtwYXJzZWRWYWx1ZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQm9keTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9wYXJzZUJvZHkudHNcbmZ1bmN0aW9uIHBhcnNlQm9keShib2R5MiwgaGVhZGVycykge1xuICB2YXIgX2E7XG4gIGlmICghYm9keTIpIHtcbiAgICByZXR1cm4gYm9keTI7XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSAoKF9hID0gaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICBjb25zdCBoYXNNdWx0aXBhcnRDb250ZW50ID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChcIm11bHRpcGFydC9mb3JtLWRhdGFcIik7XG4gIGlmIChoYXNNdWx0aXBhcnRDb250ZW50ICYmIHR5cGVvZiBib2R5MiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBwYXJzZU11bHRpcGFydERhdGEoYm9keTIudG9TdHJpbmcoKSwgaGVhZGVycykgfHwgYm9keTI7XG4gIH1cbiAgY29uc3QgaGFzSnNvbkNvbnRlbnQgPSBjb250ZW50VHlwZS5pbmNsdWRlcyhcImpzb25cIik7XG4gIGlmIChoYXNKc29uQ29udGVudCAmJiB0eXBlb2YgYm9keTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ganNvblBhcnNlKGJvZHkyLnRvU3RyaW5nKCkpIHx8IGJvZHkyO1xuICB9XG4gIHJldHVybiBib2R5Mjtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzU3RyaW5nRXF1YWwudHNcbmZ1bmN0aW9uIGlzU3RyaW5nRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICByZXR1cm4gYWN0dWFsLnRvTG93ZXJDYXNlKCkgPT09IGV4cGVjdGVkLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L01vY2tlZFJlcXVlc3QudHNcbnZhciBNb2NrZWRSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfaW50ZXJjZXB0b3JzLklzb21vcnBoaWNSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IodXJsLCBpbml0ID0ge30pIHtcbiAgICBzdXBlcih1cmwsIGluaXQpO1xuICAgIGlmIChpbml0LmlkKSB7XG4gICAgICB0aGlzLmlkID0gaW5pdC5pZDtcbiAgICB9XG4gICAgdGhpcy5jYWNoZSA9IGluaXQuY2FjaGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgdGhpcy5kZXN0aW5hdGlvbiA9IGluaXQuZGVzdGluYXRpb24gfHwgXCJcIjtcbiAgICB0aGlzLmludGVncml0eSA9IGluaXQuaW50ZWdyaXR5IHx8IFwiXCI7XG4gICAgdGhpcy5rZWVwYWxpdmUgPSBpbml0LmtlZXBhbGl2ZSB8fCBmYWxzZTtcbiAgICB0aGlzLm1vZGUgPSBpbml0Lm1vZGUgfHwgXCJjb3JzXCI7XG4gICAgdGhpcy5wcmlvcml0eSA9IGluaXQucHJpb3JpdHkgfHwgXCJhdXRvXCI7XG4gICAgdGhpcy5yZWRpcmVjdCA9IGluaXQucmVkaXJlY3QgfHwgXCJmb2xsb3dcIjtcbiAgICB0aGlzLnJlZmVycmVyID0gaW5pdC5yZWZlcnJlciB8fCBcIlwiO1xuICAgIHRoaXMucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5IHx8IFwibm8tcmVmZXJyZXJcIjtcbiAgICB0aGlzLmNvb2tpZXMgPSBpbml0LmNvb2tpZXMgfHwgdGhpcy5nZXRDb29raWVzKCk7XG4gIH1cbiAgZ2V0IGJvZHkoKSB7XG4gICAgY29uc3QgdGV4dDIgPSAoMCwgaW1wb3J0X2J1ZmZlclV0aWxzLmRlY29kZUJ1ZmZlcikodGhpc1tcIl9ib2R5XCJdKTtcbiAgICBjb25zdCBib2R5MiA9IHBhcnNlQm9keSh0ZXh0MiwgdGhpcy5oZWFkZXJzKTtcbiAgICBpZiAoaXNTdHJpbmdFcXVhbCh0aGlzLm1ldGhvZCwgXCJHRVRcIikgJiYgYm9keTIgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBib2R5MjtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAxMDEsXG4gICAgICBzdGF0dXNUZXh0OiBcIkNvbnRpbnVlXCIsXG4gICAgICBoZWFkZXJzOiBuZXcgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw0LkhlYWRlcnMoKSxcbiAgICAgIGJvZHk6IG51bGwsXG4gICAgICBwYXNzdGhyb3VnaDogdHJ1ZSxcbiAgICAgIG9uY2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBnZXRDb29raWVzKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXF1ZXN0Q29va2llc1N0cmluZyA9IHRoaXMuaGVhZGVycy5nZXQoXCJjb29raWVcIik7XG4gICAgY29uc3Qgb3duQ29va2llcyA9IHJlcXVlc3RDb29raWVzU3RyaW5nID8gY29va2llVXRpbHMzLnBhcnNlKHJlcXVlc3RDb29raWVzU3RyaW5nKSA6IHt9O1xuICAgIGltcG9ydF9jb29raWVzLnN0b3JlLmh5ZHJhdGUoKTtcbiAgICBjb25zdCBjb29raWVzRnJvbVN0b3JlID0gQXJyYXkuZnJvbShcbiAgICAgIChfYSA9IGltcG9ydF9jb29raWVzLnN0b3JlLmdldCh7IC4uLnRoaXMsIHVybDogdGhpcy51cmwuaHJlZiB9KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVudHJpZXMoKVxuICAgICkucmVkdWNlKChjb29raWVzLCBbbmFtZSwgeyB2YWx1ZSB9XSkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29va2llcywgeyBbbmFtZS50cmltKCldOiB2YWx1ZSB9KTtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgY29va2llc0Zyb21Eb2N1bWVudCA9IGdldFJlcXVlc3RDb29raWVzKHRoaXMpO1xuICAgIGNvbnN0IGZvcndhcmRlZENvb2tpZXMgPSB7XG4gICAgICAuLi5jb29raWVzRnJvbURvY3VtZW50LFxuICAgICAgLi4uY29va2llc0Zyb21TdG9yZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcndhcmRlZENvb2tpZXMpKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKFwiY29va2llXCIsIGAke25hbWV9PSR7dmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3J3YXJkZWRDb29raWVzLFxuICAgICAgLi4ub3duQ29va2llc1xuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L3BhcnNlV29ya2VyUmVxdWVzdC50c1xuZnVuY3Rpb24gcGFyc2VXb3JrZXJSZXF1ZXN0KHJhd1JlcXVlc3QpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChyYXdSZXF1ZXN0LnVybCk7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw1LkhlYWRlcnMocmF3UmVxdWVzdC5oZWFkZXJzKTtcbiAgcmV0dXJuIG5ldyBNb2NrZWRSZXF1ZXN0KHVybCwge1xuICAgIC4uLnJhd1JlcXVlc3QsXG4gICAgYm9keTogKDAsIGltcG9ydF9pbnRlcmNlcHRvcnMyLmVuY29kZUJ1ZmZlcikocmF3UmVxdWVzdC5ib2R5IHx8IFwiXCIpLFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG52YXIgaW1wb3J0X3VudGlsMiA9IHJlcXVpcmUoXCJAb3Blbi1kcmFmdC91bnRpbFwiKTtcblxuLy8gc3JjL3V0aWxzL2dldFJlc3BvbnNlLnRzXG52YXIgZ2V0UmVzcG9uc2UgPSBhc3luYyAocmVxdWVzdCwgaGFuZGxlcnMsIHJlc29sdXRpb25Db250ZXh0KSA9PiB7XG4gIGNvbnN0IHJlbGV2YW50SGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoKGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gaGFuZGxlci50ZXN0KHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgfSk7XG4gIGlmIChyZWxldmFudEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB2b2lkIDAsXG4gICAgICByZXNwb25zZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWxldmFudEhhbmRsZXJzLnJlZHVjZShhc3luYyAoZXhlY3V0aW9uUmVzdWx0LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNSZXN1bHRzID0gYXdhaXQgZXhlY3V0aW9uUmVzdWx0O1xuICAgIGlmICghIShwcmV2aW91c1Jlc3VsdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzUmVzdWx0cy5yZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBleGVjdXRpb25SZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBoYW5kbGVyLnJ1bihyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCk7XG4gICAgaWYgKHJlc3VsdDIgPT09IG51bGwgfHwgcmVzdWx0Mi5oYW5kbGVyLnNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdDIucmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IHJlc3VsdDIucmVxdWVzdCxcbiAgICAgICAgaGFuZGxlcjogcmVzdWx0Mi5oYW5kbGVyLFxuICAgICAgICByZXNwb25zZTogdm9pZCAwLFxuICAgICAgICBwYXJzZWRSZXN1bHQ6IHJlc3VsdDIucGFyc2VkUmVzdWx0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0Mi5yZXNwb25zZS5vbmNlKSB7XG4gICAgICBoYW5kbGVyLm1hcmtBc1NraXBwZWQodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB2b2lkIDAsXG4gICAgICByZXNwb25zZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IHJlc3VsdC5oYW5kbGVyLFxuICAgIHB1YmxpY1JlcXVlc3Q6IHJlc3VsdC5yZXF1ZXN0LFxuICAgIHBhcnNlZFJlcXVlc3Q6IHJlc3VsdC5wYXJzZWRSZXN1bHQsXG4gICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3Qvb25VbmhhbmRsZWRSZXF1ZXN0LnRzXG52YXIgaW1wb3J0X2pzX2xldmVuc2h0ZWluID0gX190b0VTTShyZXF1aXJlKFwianMtbGV2ZW5zaHRlaW5cIikpO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VHcmFwaFFMUmVxdWVzdC50c1xudmFyIGltcG9ydF9ncmFwaHFsID0gcmVxdWlyZShcImdyYXBocWxcIik7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFB1YmxpY1VybEZyb21SZXF1ZXN0LnRzXG52YXIgZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QgPSAocmVxdWVzdCkgPT4ge1xuICByZXR1cm4gcmVxdWVzdC5yZWZlcnJlci5zdGFydHNXaXRoKHJlcXVlc3QudXJsLm9yaWdpbikgPyByZXF1ZXN0LnVybC5wYXRobmFtZSA6IG5ldyBVUkwoXG4gICAgcmVxdWVzdC51cmwucGF0aG5hbWUsXG4gICAgYCR7cmVxdWVzdC51cmwucHJvdG9jb2x9Ly8ke3JlcXVlc3QudXJsLmhvc3R9YFxuICApLmhyZWY7XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VHcmFwaFFMUmVxdWVzdC50c1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudE5vZGUobm9kZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG9wZXJhdGlvbkRlZiA9IG5vZGUuZGVmaW5pdGlvbnMuZmluZCgoZGVmKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIjtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uVHlwZTogb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYub3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbk5hbWU6IChfYSA9IG9wZXJhdGlvbkRlZiA9PSBudWxsID8gdm9pZCAwIDogb3BlcmF0aW9uRGVmLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VRdWVyeShxdWVyeSkge1xuICB0cnkge1xuICAgIGNvbnN0IGFzdCA9ICgwLCBpbXBvcnRfZ3JhcGhxbC5wYXJzZSkocXVlcnkpO1xuICAgIHJldHVybiBwYXJzZURvY3VtZW50Tm9kZShhc3QpO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICByZXR1cm4gZXJyb3IyO1xuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0TXVsdGlwYXJ0VmFyaWFibGVzKHZhcmlhYmxlcywgbWFwLCBmaWxlcykge1xuICBjb25zdCBvcGVyYXRpb25zID0geyB2YXJpYWJsZXMgfTtcbiAgZm9yIChjb25zdCBba2V5LCBwYXRoQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICBpZiAoIShrZXkgaW4gZmlsZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdmVuIGZpbGVzIGRvIG5vdCBoYXZlIGEga2V5ICcke2tleX0nIC5gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb3RQYXRoIG9mIHBhdGhBcnJheSkge1xuICAgICAgY29uc3QgW2xhc3RQYXRoLCAuLi5yZXZlcnNlZFBhdGhzXSA9IGRvdFBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgIGNvbnN0IHBhdGhzID0gcmV2ZXJzZWRQYXRocy5yZXZlcnNlKCk7XG4gICAgICBsZXQgdGFyZ2V0ID0gb3BlcmF0aW9ucztcbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBpZiAoIShwYXRoIGluIHRhcmdldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5ICcke3BhdGhzfScgaXMgbm90IGluIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3BhdGhdO1xuICAgICAgfVxuICAgICAgdGFyZ2V0W2xhc3RQYXRoXSA9IGZpbGVzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvcGVyYXRpb25zLnZhcmlhYmxlcztcbn1cbmZ1bmN0aW9uIGdldEdyYXBoUUxJbnB1dChyZXF1ZXN0KSB7XG4gIHZhciBfYSwgX2I7XG4gIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICBjYXNlIFwiR0VUXCI6IHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gcmVxdWVzdC51cmwuc2VhcmNoUGFyYW1zLmdldChcInF1ZXJ5XCIpO1xuICAgICAgY29uc3QgdmFyaWFibGVzID0gcmVxdWVzdC51cmwuc2VhcmNoUGFyYW1zLmdldChcInZhcmlhYmxlc1wiKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHZhcmlhYmxlczoganNvblBhcnNlKHZhcmlhYmxlcylcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJQT1NUXCI6IHtcbiAgICAgIGlmICgoX2EgPSByZXF1ZXN0LmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWVyeSkge1xuICAgICAgICBjb25zdCB7IHF1ZXJ5LCB2YXJpYWJsZXMgfSA9IHJlcXVlc3QuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB2YXJpYWJsZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2IgPSByZXF1ZXN0LmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgb3BlcmF0aW9ucywgbWFwLCAuLi5maWxlcyB9ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICBjb25zdCBwYXJzZWRPcGVyYXRpb25zID0ganNvblBhcnNlKFxuICAgICAgICAgIG9wZXJhdGlvbnNcbiAgICAgICAgKSB8fCB7fTtcbiAgICAgICAgaWYgKCFwYXJzZWRPcGVyYXRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkTWFwID0ganNvblBhcnNlKG1hcCB8fCBcIlwiKSB8fCB7fTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gcGFyc2VkT3BlcmF0aW9ucy52YXJpYWJsZXMgPyBleHRyYWN0TXVsdGlwYXJ0VmFyaWFibGVzKFxuICAgICAgICAgIHBhcnNlZE9wZXJhdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgIHBhcnNlZE1hcCxcbiAgICAgICAgICBmaWxlc1xuICAgICAgICApIDoge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcXVlcnk6IHBhcnNlZE9wZXJhdGlvbnMucXVlcnksXG4gICAgICAgICAgdmFyaWFibGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VHcmFwaFFMUmVxdWVzdChyZXF1ZXN0KSB7XG4gIGNvbnN0IGlucHV0ID0gZ2V0R3JhcGhRTElucHV0KHJlcXVlc3QpO1xuICBpZiAoIWlucHV0IHx8ICFpbnB1dC5xdWVyeSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgeyBxdWVyeSwgdmFyaWFibGVzIH0gPSBpbnB1dDtcbiAgY29uc3QgcGFyc2VkUmVzdWx0ID0gcGFyc2VRdWVyeShxdWVyeSk7XG4gIGlmIChwYXJzZWRSZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNvbnN0IHJlcXVlc3RQdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAnRmFpbGVkIHRvIGludGVyY2VwdCBhIEdyYXBoUUwgcmVxdWVzdCB0byBcIiVzICVzXCI6IGNhbm5vdCBwYXJzZSBxdWVyeS4gU2VlIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhlIHBhcnNlciBiZWxvdy5cXG5cXG4lcycsXG4gICAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgICByZXF1ZXN0UHVibGljVXJsLFxuICAgICAgICBwYXJzZWRSZXN1bHQubWVzc2FnZVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb25UeXBlOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uVHlwZSxcbiAgICBvcGVyYXRpb25OYW1lOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSxcbiAgICB2YXJpYWJsZXNcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0U3RhdHVzQ29kZUNvbG9yLnRzXG5mdW5jdGlvbiBnZXRTdGF0dXNDb2RlQ29sb3Ioc3RhdHVzMikge1xuICBpZiAoc3RhdHVzMiA8IDMwMCkge1xuICAgIHJldHVybiBcIiM2OUFCMzJcIiAvKiBTdWNjZXNzICovO1xuICB9XG4gIGlmIChzdGF0dXMyIDwgNDAwKSB7XG4gICAgcmV0dXJuIFwiI0YwQkI0QlwiIC8qIFdhcm5pbmcgKi87XG4gIH1cbiAgcmV0dXJuIFwiI0U5NUY1RFwiIC8qIERhbmdlciAqLztcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvZ2V0VGltZXN0YW1wLnRzXG5mdW5jdGlvbiBnZXRUaW1lc3RhbXAoKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIHJldHVybiBbbm93LmdldEhvdXJzKCksIG5vdy5nZXRNaW51dGVzKCksIG5vdy5nZXRTZWNvbmRzKCldLm1hcChTdHJpbmcpLm1hcCgoY2h1bmspID0+IGNodW5rLnNsaWNlKDAsIDIpKS5tYXAoKGNodW5rKSA9PiBjaHVuay5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCI6XCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVxdWVzdC50c1xuZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycy5hbGwoKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbG9nZ2luZy9wcmVwYXJlUmVzcG9uc2UudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDYgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZShyZXMpIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gKDAsIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNi5vYmplY3RUb0hlYWRlcnMpKHJlcy5oZWFkZXJzKTtcbiAgY29uc3QgcGFyc2VkQm9keSA9IHBhcnNlQm9keShyZXMuYm9keSwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXMsXG4gICAgYm9keTogcGFyc2VkQm9keVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbWF0Y2hpbmcvbWF0Y2hSZXF1ZXN0VXJsLnRzXG52YXIgaW1wb3J0X3BhdGhfdG9fcmVnZXhwID0gcmVxdWlyZShcInBhdGgtdG8tcmVnZXhwXCIpO1xudmFyIGltcG9ydF9nZXRDbGVhblVybCA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi91dGlscy9nZXRDbGVhblVybC5qc1wiKTtcblxuLy8gc3JjL3V0aWxzL3VybC9jbGVhblVybC50c1xudmFyIFJFRFVOREFOVF9DSEFSQUNURVJTX0VYUCA9IC9bXFw/fCNdLiokL2c7XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXMocGF0aCkge1xuICByZXR1cm4gbmV3IFVSTChgLyR7cGF0aH1gLCBcImh0dHA6Ly9sb2NhbGhvc3RcIikuc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gY2xlYW5VcmwocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKFJFRFVOREFOVF9DSEFSQUNURVJTX0VYUCwgXCJcIik7XG59XG5cbi8vIHNyYy91dGlscy91cmwvaXNBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuXG4vLyBzcmMvdXRpbHMvdXJsL2dldEFic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVVybChwYXRoLCBiYXNlVXJsKSB7XG4gIGlmIChpc0Fic29sdXRlVXJsKHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIipcIikpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBjb25zdCBvcmlnaW4gPSBiYXNlVXJsIHx8IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5iYXNlVVJJO1xuICByZXR1cm4gb3JpZ2luID8gZGVjb2RlVVJJKG5ldyBVUkwoZW5jb2RlVVJJKHBhdGgpLCBvcmlnaW4pLmhyZWYpIDogcGF0aDtcbn1cblxuLy8gc3JjL3V0aWxzL21hdGNoaW5nL25vcm1hbGl6ZVBhdGgudHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aCwgYmFzZVVybCkge1xuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGNvbnN0IG1heWJlQWJzb2x1dGVVcmwgPSBnZXRBYnNvbHV0ZVVybChwYXRoLCBiYXNlVXJsKTtcbiAgcmV0dXJuIGNsZWFuVXJsKG1heWJlQWJzb2x1dGVVcmwpO1xufVxuXG4vLyBzcmMvdXRpbHMvbWF0Y2hpbmcvbWF0Y2hSZXF1ZXN0VXJsLnRzXG5mdW5jdGlvbiBjb2VyY2VQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShcbiAgICAvKFs6YS16QS1aXy1dKikoXFwqezEsMn0pKy9nLFxuICAgIChfLCBwYXJhbWV0ZXJOYW1lLCB3aWxkY2FyZCkgPT4ge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFwiKC4qKVwiO1xuICAgICAgaWYgKCFwYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtZXRlck5hbWUuc3RhcnRzV2l0aChcIjpcIikgPyBgJHtwYXJhbWV0ZXJOYW1lfSR7d2lsZGNhcmR9YCA6IGAke3BhcmFtZXRlck5hbWV9JHtleHByZXNzaW9ufWA7XG4gICAgfVxuICApLnJlcGxhY2UoLyhbXlxcL10pKDopKD89XFxkKykvLCBcIiQxXFxcXCQyXCIpLnJlcGxhY2UoL14oW15cXC9dKykoOikoPz1cXC9cXC8pLywgXCIkMVxcXFwkMlwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUmVxdWVzdFVybCh1cmwsIHBhdGgsIGJhc2VVcmwpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgsIGJhc2VVcmwpO1xuICBjb25zdCBjbGVhblBhdGggPSB0eXBlb2Ygbm9ybWFsaXplZFBhdGggPT09IFwic3RyaW5nXCIgPyBjb2VyY2VQYXRoKG5vcm1hbGl6ZWRQYXRoKSA6IG5vcm1hbGl6ZWRQYXRoO1xuICBjb25zdCBjbGVhblVybDIgPSAoMCwgaW1wb3J0X2dldENsZWFuVXJsLmdldENsZWFuVXJsKSh1cmwpO1xuICBjb25zdCByZXN1bHQgPSAoMCwgaW1wb3J0X3BhdGhfdG9fcmVnZXhwLm1hdGNoKShjbGVhblBhdGgsIHsgZGVjb2RlOiBkZWNvZGVVUklDb21wb25lbnQgfSkoY2xlYW5VcmwyKTtcbiAgY29uc3QgcGFyYW1zID0gcmVzdWx0ICYmIHJlc3VsdC5wYXJhbXMgfHwge307XG4gIHJldHVybiB7XG4gICAgbWF0Y2hlczogcmVzdWx0ICE9PSBmYWxzZSxcbiAgICBwYXJhbXNcbiAgfTtcbn1cblxuLy8gc3JjL2hhbmRsZXJzL1JlcXVlc3RIYW5kbGVyLnRzXG52YXIgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw4ID0gcmVxdWlyZShcImhlYWRlcnMtcG9seWZpbGxcIik7XG5cbi8vIHNyYy9yZXNwb25zZS50c1xudmFyIGltcG9ydF9oZWFkZXJzX3BvbHlmaWxsNyA9IHJlcXVpcmUoXCJoZWFkZXJzLXBvbHlmaWxsXCIpO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvY29tcG9zZS50c1xuZnVuY3Rpb24gY29tcG9zZSguLi5mbnMpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2VSaWdodCgobGVmdEZuLCByaWdodEZuKSA9PiB7XG4gICAgICByZXR1cm4gbGVmdEZuIGluc3RhbmNlb2YgUHJvbWlzZSA/IFByb21pc2UucmVzb2x2ZShsZWZ0Rm4pLnRoZW4ocmlnaHRGbikgOiByaWdodEZuKGxlZnRGbik7XG4gICAgfSwgYXJnc1swXSk7XG4gIH07XG59XG5cbi8vIHNyYy9yZXNwb25zZS50c1xudmFyIGRlZmF1bHRSZXNwb25zZSA9IHtcbiAgc3RhdHVzOiAyMDAsXG4gIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgYm9keTogbnVsbCxcbiAgZGVsYXk6IDAsXG4gIG9uY2U6IGZhbHNlLFxuICBwYXNzdGhyb3VnaDogZmFsc2Vcbn07XG52YXIgZGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHJlc3BvbnNlT3ZlcnJpZGVzLCBkZWZhdWx0VHJhbnNmb3JtZXJzID0gZGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJzKSB7XG4gIHJldHVybiBhc3luYyAoLi4udHJhbnNmb3JtZXJzKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgZGVmYXVsdFJlc3BvbnNlLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBuZXcgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw3LkhlYWRlcnMoe1xuICAgICAgICAgIFwieC1wb3dlcmVkLWJ5XCI6IFwibXN3XCJcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU92ZXJyaWRlc1xuICAgICk7XG4gICAgY29uc3QgcmVzb2x2ZWRUcmFuc2Zvcm1lcnMgPSBbXG4gICAgICAuLi5kZWZhdWx0VHJhbnNmb3JtZXJzLFxuICAgICAgLi4udHJhbnNmb3JtZXJzXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgcmVzb2x2ZWRSZXNwb25zZSA9IHJlc29sdmVkVHJhbnNmb3JtZXJzLmxlbmd0aCA+IDAgPyBjb21wb3NlKC4uLnJlc29sdmVkVHJhbnNmb3JtZXJzKShpbml0aWFsUmVzcG9uc2UpIDogaW5pdGlhbFJlc3BvbnNlO1xuICAgIHJldHVybiByZXNvbHZlZFJlc3BvbnNlO1xuICB9O1xufVxudmFyIHJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKCksIHtcbiAgb25jZTogY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbih7IG9uY2U6IHRydWUgfSksXG4gIG5ldHdvcmtFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihtZXNzYWdlKTtcbiAgfVxufSk7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9nZXRDYWxsRnJhbWUudHNcbnZhciBTT1VSQ0VfRlJBTUUgPSAvW1xcL1xcXFxdbXN3W1xcL1xcXFxdc3JjW1xcL1xcXFxdKC4rKS87XG52YXIgQlVJTERfRlJBTUUgPSAvKG5vZGVfbW9kdWxlcyk/W1xcL1xcXFxdbGliW1xcL1xcXFxdKHVtZHxlc218aWllZnxjanMpW1xcL1xcXFxdfF5bXlxcL1xcXFxdKiQvO1xuZnVuY3Rpb24gZ2V0Q2FsbEZyYW1lKGVycm9yMikge1xuICBjb25zdCBzdGFjayA9IGVycm9yMi5zdGFjaztcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmcmFtZXMgPSBzdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKTtcbiAgY29uc3QgZGVjbGFyYXRpb25GcmFtZSA9IGZyYW1lcy5maW5kKChmcmFtZSkgPT4ge1xuICAgIHJldHVybiAhKFNPVVJDRV9GUkFNRS50ZXN0KGZyYW1lKSB8fCBCVUlMRF9GUkFNRS50ZXN0KGZyYW1lKSk7XG4gIH0pO1xuICBpZiAoIWRlY2xhcmF0aW9uRnJhbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVjbGFyYXRpb25QYXRoID0gZGVjbGFyYXRpb25GcmFtZS5yZXBsYWNlKC9cXHMqYXQgW14oKV0qXFwoKFteKV0rKVxcKS8sIFwiJDFcIikucmVwbGFjZSgvXkAvLCBcIlwiKTtcbiAgcmV0dXJuIGRlY2xhcmF0aW9uUGF0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzSXRlcmFibGUudHNcbmZ1bmN0aW9uIGlzSXRlcmFibGUoZm4pIHtcbiAgaWYgKCFmbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGZuW1N5bWJvbC5pdGVyYXRvcl0gPT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBkZWZhdWx0Q29udGV4dCA9IHtcbiAgc3RhdHVzLFxuICBzZXQsXG4gIGRlbGF5LFxuICBmZXRjaFxufTtcbnZhciBSZXF1ZXN0SGFuZGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IGZhbHNlO1xuICAgIHRoaXMuY3R4ID0gb3B0aW9ucy5jdHggfHwgZGVmYXVsdENvbnRleHQ7XG4gICAgdGhpcy5yZXNvbHZlciA9IG9wdGlvbnMucmVzb2x2ZXI7XG4gICAgY29uc3QgY2FsbEZyYW1lID0gZ2V0Q2FsbEZyYW1lKG5ldyBFcnJvcigpKTtcbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICAuLi5vcHRpb25zLmluZm8sXG4gICAgICBjYWxsRnJhbWVcbiAgICB9O1xuICB9XG4gIHBhcnNlKF9yZXF1ZXN0LCBfcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0ZXN0KHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgX3BhcnNlZFJlc3VsdCkge1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIG1hcmtBc1NraXBwZWQoc2hvdWxkU2tpcCA9IHRydWUpIHtcbiAgICB0aGlzLnNob3VsZFNraXAgPSBzaG91bGRTa2lwO1xuICB9XG4gIGFzeW5jIHJ1bihyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIGlmICh0aGlzLnNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRSZXN1bHQgPSB0aGlzLnBhcnNlKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBjb25zdCBzaG91bGRJbnRlcmNlcHQgPSB0aGlzLnByZWRpY2F0ZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gICAgaWYgKCFzaG91bGRJbnRlcmNlcHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNSZXF1ZXN0ID0gdGhpcy5nZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCk7XG4gICAgY29uc3QgZXhlY3V0ZVJlc29sdmVyID0gdGhpcy53cmFwUmVzb2x2ZXIodGhpcy5yZXNvbHZlcik7XG4gICAgY29uc3QgbW9ja2VkUmVzcG9uc2UgPSBhd2FpdCBleGVjdXRlUmVzb2x2ZXIoXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgcmVzcG9uc2UsXG4gICAgICB0aGlzLmN0eFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhlY3V0aW9uUmVzdWx0KFxuICAgICAgcGFyc2VkUmVzdWx0LFxuICAgICAgcHVibGljUmVxdWVzdCxcbiAgICAgIG1vY2tlZFJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICB3cmFwUmVzb2x2ZXIocmVzb2x2ZXIpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzb2x2ZXJHZW5lcmF0b3IgfHwgYXdhaXQgcmVzb2x2ZXIocmVxLCByZXMsIGN0eCk7XG4gICAgICBpZiAoaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IHJlc3VsdFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgICAgICBjb25zdCBuZXh0UmVzcG9uc2UgPSBhd2FpdCB2YWx1ZTtcbiAgICAgICAgaWYgKCFuZXh0UmVzcG9uc2UgJiYgZG9uZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlckdlbmVyYXRvcikge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3IgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvclJlc3VsdCA9IG5leHRSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIG5leHRSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBjcmVhdGVFeGVjdXRpb25SZXN1bHQocGFyc2VkUmVzdWx0LCByZXF1ZXN0LCByZXNwb25zZTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlcjogdGhpcyxcbiAgICAgIHBhcnNlZFJlc3VsdDogcGFyc2VkUmVzdWx0IHx8IG51bGwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlMiB8fCBudWxsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2hhbmRsZXJzL1Jlc3RIYW5kbGVyLnRzXG52YXIgUkVTVE1ldGhvZHMgPSAvKiBAX19QVVJFX18gKi8gKChSRVNUTWV0aG9kczIpID0+IHtcbiAgUkVTVE1ldGhvZHMyW1wiSEVBRFwiXSA9IFwiSEVBRFwiO1xuICBSRVNUTWV0aG9kczJbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICBSRVNUTWV0aG9kczJbXCJQT1NUXCJdID0gXCJQT1NUXCI7XG4gIFJFU1RNZXRob2RzMltcIlBVVFwiXSA9IFwiUFVUXCI7XG4gIFJFU1RNZXRob2RzMltcIlBBVENIXCJdID0gXCJQQVRDSFwiO1xuICBSRVNUTWV0aG9kczJbXCJPUFRJT05TXCJdID0gXCJPUFRJT05TXCI7XG4gIFJFU1RNZXRob2RzMltcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG4gIHJldHVybiBSRVNUTWV0aG9kczI7XG59KShSRVNUTWV0aG9kcyB8fCB7fSk7XG52YXIgcmVzdENvbnRleHQgPSB7XG4gIC4uLmRlZmF1bHRDb250ZXh0LFxuICBjb29raWUsXG4gIGJvZHksXG4gIHRleHQsXG4gIGpzb24sXG4gIHhtbFxufTtcbnZhciBSZXN0UmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgTW9ja2VkUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QsIHBhcmFtcykge1xuICAgIHN1cGVyKHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogcmVxdWVzdFtcIl9ib2R5XCJdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5pZCA9IHJlcXVlc3QuaWQ7XG4gIH1cbn07XG52YXIgUmVzdEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIFJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IobWV0aG9kLCBwYXRoLCByZXNvbHZlcikge1xuICAgIHN1cGVyKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaGVhZGVyOiBgJHttZXRob2R9ICR7cGF0aH1gLFxuICAgICAgICBwYXRoLFxuICAgICAgICBtZXRob2RcbiAgICAgIH0sXG4gICAgICBjdHg6IHJlc3RDb250ZXh0LFxuICAgICAgcmVzb2x2ZXJcbiAgICB9KTtcbiAgICB0aGlzLmNoZWNrUmVkdW5kYW50UXVlcnlQYXJhbWV0ZXJzKCk7XG4gIH1cbiAgY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgeyBtZXRob2QsIHBhdGggfSA9IHRoaXMuaW5mbztcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBjbGVhblVybChwYXRoKTtcbiAgICBpZiAodXJsID09PSBwYXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IGdldFNlYXJjaFBhcmFtcyhwYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IFtdO1xuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBwYXJhbU5hbWUpID0+IHtcbiAgICAgIHF1ZXJ5UGFyYW1zLnB1c2gocGFyYW1OYW1lKTtcbiAgICB9KTtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYEZvdW5kIGEgcmVkdW5kYW50IHVzYWdlIG9mIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlcXVlc3QgaGFuZGxlciBVUkwgZm9yIFwiJHttZXRob2R9ICR7cGF0aH1cIi4gUGxlYXNlIG1hdGNoIGFnYWluc3QgYSBwYXRoIGluc3RlYWQgYW5kIGFjY2VzcyBxdWVyeSBwYXJhbWV0ZXJzIGluIHRoZSByZXNwb25zZSByZXNvbHZlciBmdW5jdGlvbiB1c2luZyBcInJlcS51cmwuc2VhcmNoUGFyYW1zXCIuYFxuICAgICk7XG4gIH1cbiAgcGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gbWF0Y2hSZXF1ZXN0VXJsKFxuICAgICAgcmVxdWVzdC51cmwsXG4gICAgICB0aGlzLmluZm8ucGF0aCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByZXNvbHV0aW9uQ29udGV4dC5iYXNlVXJsXG4gICAgKTtcbiAgfVxuICBnZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIHJldHVybiBuZXcgUmVzdFJlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0LnBhcmFtcyB8fCB7fSk7XG4gIH1cbiAgcHJlZGljYXRlKHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIGNvbnN0IG1hdGNoZXNNZXRob2QgPSB0aGlzLmluZm8ubWV0aG9kIGluc3RhbmNlb2YgUmVnRXhwID8gdGhpcy5pbmZvLm1ldGhvZC50ZXN0KHJlcXVlc3QubWV0aG9kKSA6IGlzU3RyaW5nRXF1YWwodGhpcy5pbmZvLm1ldGhvZCwgcmVxdWVzdC5tZXRob2QpO1xuICAgIHJldHVybiBtYXRjaGVzTWV0aG9kICYmIHBhcnNlZFJlc3VsdC5tYXRjaGVzO1xuICB9XG4gIGxvZyhyZXF1ZXN0LCByZXNwb25zZTIpIHtcbiAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVzcG9uc2UgPSBwcmVwYXJlUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldFN0YXR1c0NvZGVDb2xvcihyZXNwb25zZTIuc3RhdHVzKTtcbiAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcIiVzICVzICVzICglYyVzJWMpXCIpLFxuICAgICAgZ2V0VGltZXN0YW1wKCksXG4gICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIHB1YmxpY1VybCxcbiAgICAgIGBjb2xvcjoke3N0YXR1c0NvbG9yfWAsXG4gICAgICBgJHtyZXNwb25zZTIuc3RhdHVzfSAke3Jlc3BvbnNlMi5zdGF0dXNUZXh0fWAsXG4gICAgICBcImNvbG9yOmluaGVyaXRcIlxuICAgICk7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0XCIsIGxvZ2dlZFJlcXVlc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiSGFuZGxlcjpcIiwgdGhpcyk7XG4gICAgY29uc29sZS5sb2coXCJSZXNwb25zZVwiLCBsb2dnZWRSZXNwb25zZSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvY29udGV4dC9maWVsZC50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50MyA9IHJlcXVpcmUoXCJvdXR2YXJpYW50XCIpO1xudmFyIGZpZWxkID0gKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSk7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkTmFtZShmaWVsZE5hbWUpIHtcbiAgKDAsIGltcG9ydF9vdXR2YXJpYW50My5pbnZhcmlhbnQpKFxuICAgIGZpZWxkTmFtZS50cmltKCkgIT09IFwiXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgIFwiRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBmaWVsZCBvbiBhIEdyYXBoUUwgcmVzcG9uc2U6IGZpZWxkIG5hbWUgY2Fubm90IGJlIGVtcHR5LlwiXG4gICAgKVxuICApO1xuICAoMCwgaW1wb3J0X291dHZhcmlhbnQzLmludmFyaWFudCkoXG4gICAgZmllbGROYW1lICE9PSBcImRhdGFcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5kYXRhKClcIiBpbnN0ZWFkPycsXG4gICAgICBmaWVsZE5hbWVcbiAgICApXG4gICk7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDMuaW52YXJpYW50KShcbiAgICBmaWVsZE5hbWUgIT09IFwiZXJyb3JzXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZXJyb3JzKClcIiBpbnN0ZWFkPycsXG4gICAgICBmaWVsZE5hbWVcbiAgICApXG4gICk7XG4gICgwLCBpbXBvcnRfb3V0dmFyaWFudDMuaW52YXJpYW50KShcbiAgICBmaWVsZE5hbWUgIT09IFwiZXh0ZW5zaW9uc1wiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmV4dGVuc2lvbnMoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3RyeUNhdGNoLnRzXG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb25FeGNlcHRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIG9uRXhjZXB0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkV4Y2VwdGlvbihlcnJvcjIpO1xuICB9XG59XG5cbi8vIHNyYy9oYW5kbGVycy9HcmFwaFFMSGFuZGxlci50c1xudmFyIGdyYXBocWxDb250ZXh0ID0ge1xuICAuLi5kZWZhdWx0Q29udGV4dCxcbiAgZGF0YSxcbiAgZXh0ZW5zaW9ucyxcbiAgZXJyb3JzLFxuICBjb29raWUsXG4gIGZpZWxkXG59O1xuZnVuY3Rpb24gaXNEb2N1bWVudE5vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImtpbmRcIiBpbiB2YWx1ZSAmJiBcImRlZmluaXRpb25zXCIgaW4gdmFsdWU7XG59XG52YXIgR3JhcGhRTFJlcXVlc3QgPSBjbGFzcyBleHRlbmRzIE1vY2tlZFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCB2YXJpYWJsZXMsIG9wZXJhdGlvbk5hbWUpIHtcbiAgICBzdXBlcihyZXF1ZXN0LnVybCwge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIGJvZHk6IHJlcXVlc3RbXCJfYm9keVwiXVxuICAgIH0pO1xuICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgIHRoaXMub3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gIH1cbn07XG52YXIgR3JhcGhRTEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIFJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9uVHlwZSwgb3BlcmF0aW9uTmFtZSwgZW5kcG9pbnQsIHJlc29sdmVyKSB7XG4gICAgbGV0IHJlc29sdmVkT3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG4gICAgaWYgKGlzRG9jdW1lbnROb2RlKG9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBwYXJzZWROb2RlID0gcGFyc2VEb2N1bWVudE5vZGUob3BlcmF0aW9uTmFtZSk7XG4gICAgICBpZiAocGFyc2VkTm9kZS5vcGVyYXRpb25UeXBlICE9PSBvcGVyYXRpb25UeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBhIG1pc21hdGNoZWQgb3BlcmF0aW9uIHR5cGUgKGV4cGVjdGVkIFwiJHtvcGVyYXRpb25UeXBlfVwiLCBidXQgZ290IFwiJHtwYXJzZWROb2RlLm9wZXJhdGlvblR5cGV9XCIpLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VkTm9kZS5vcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBhIEdyYXBoUUwgaGFuZGxlcjogcHJvdmlkZWQgYSBEb2N1bWVudE5vZGUgd2l0aCBubyBvcGVyYXRpb24gbmFtZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZE9wZXJhdGlvbk5hbWUgPSBwYXJzZWROb2RlLm9wZXJhdGlvbk5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IG9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgPyBgJHtvcGVyYXRpb25UeXBlfSAob3JpZ2luOiAke2VuZHBvaW50LnRvU3RyaW5nKCl9KWAgOiBgJHtvcGVyYXRpb25UeXBlfSAke3Jlc29sdmVkT3BlcmF0aW9uTmFtZX0gKG9yaWdpbjogJHtlbmRwb2ludC50b1N0cmluZygpfSlgO1xuICAgIHN1cGVyKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBvcGVyYXRpb25UeXBlLFxuICAgICAgICBvcGVyYXRpb25OYW1lOiByZXNvbHZlZE9wZXJhdGlvbk5hbWVcbiAgICAgIH0sXG4gICAgICBjdHg6IGdyYXBocWxDb250ZXh0LFxuICAgICAgcmVzb2x2ZXJcbiAgICB9KTtcbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gIH1cbiAgcGFyc2UocmVxdWVzdCkge1xuICAgIHJldHVybiB0cnlDYXRjaChcbiAgICAgICgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCksXG4gICAgICAoZXJyb3IyKSA9PiBjb25zb2xlLmVycm9yKGVycm9yMi5tZXNzYWdlKVxuICAgICk7XG4gIH1cbiAgZ2V0UHVibGljUmVxdWVzdChyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBuZXcgR3JhcGhRTFJlcXVlc3QoXG4gICAgICByZXF1ZXN0LFxuICAgICAgKF9hID0gcGFyc2VkUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXN1bHQudmFyaWFibGVzKSAhPSBudWxsID8gX2EgOiB7fSxcbiAgICAgIChfYiA9IHBhcnNlZFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUpICE9IG51bGwgPyBfYiA6IFwiXCJcbiAgICApO1xuICB9XG4gIHByZWRpY2F0ZShyZXF1ZXN0LCBwYXJzZWRSZXN1bHQpIHtcbiAgICBpZiAoIXBhcnNlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lICYmIHRoaXMuaW5mby5vcGVyYXRpb25UeXBlICE9PSBcImFsbFwiKSB7XG4gICAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgIGRldlV0aWxzLndhcm4oYEZhaWxlZCB0byBpbnRlcmNlcHQgYSBHcmFwaFFMIHJlcXVlc3QgYXQgXCIke3JlcXVlc3QubWV0aG9kfSAke3B1YmxpY1VybH1cIjogYW5vbnltb3VzIEdyYXBoUUwgb3BlcmF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZC5cblxuQ29uc2lkZXIgbmFtaW5nIHRoaXMgb3BlcmF0aW9uIG9yIHVzaW5nIFwiZ3JhcGhxbC5vcGVyYXRpb24oKVwiIHJlcXVlc3QgaGFuZGxlciB0byBpbnRlcmNlcHQgR3JhcGhRTCByZXF1ZXN0cyByZWdhcmRsZXNzIG9mIHRoZWlyIG9wZXJhdGlvbiBuYW1lL3R5cGUuIFJlYWQgbW9yZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL2FwaS9ncmFwaHFsL29wZXJhdGlvbiAgICAgIGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoYXNNYXRjaGluZ1VybCA9IG1hdGNoUmVxdWVzdFVybChyZXF1ZXN0LnVybCwgdGhpcy5lbmRwb2ludCk7XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdPcGVyYXRpb25UeXBlID0gdGhpcy5pbmZvLm9wZXJhdGlvblR5cGUgPT09IFwiYWxsXCIgfHwgcGFyc2VkUmVzdWx0Lm9wZXJhdGlvblR5cGUgPT09IHRoaXMuaW5mby5vcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nT3BlcmF0aW9uTmFtZSA9IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lIGluc3RhbmNlb2YgUmVnRXhwID8gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWUudGVzdChwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSB8fCBcIlwiKSA6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lID09PSB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZTtcbiAgICByZXR1cm4gaGFzTWF0Y2hpbmdVcmwubWF0Y2hlcyAmJiBoYXNNYXRjaGluZ09wZXJhdGlvblR5cGUgJiYgaGFzTWF0Y2hpbmdPcGVyYXRpb25OYW1lO1xuICB9XG4gIGxvZyhyZXF1ZXN0LCByZXNwb25zZTIsIHBhcnNlZFJlcXVlc3QpIHtcbiAgICBjb25zdCBsb2dnZWRSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVzcG9uc2UgPSBwcmVwYXJlUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldFN0YXR1c0NvZGVDb2xvcihyZXNwb25zZTIuc3RhdHVzKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IChwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvbk5hbWUpID8gYCR7cGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25UeXBlfSAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uTmFtZX1gIDogYGFub255bW91cyAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uVHlwZX1gO1xuICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiJXMgJXMgKCVjJXMlYylcIiksXG4gICAgICBnZXRUaW1lc3RhbXAoKSxcbiAgICAgIGAke3JlcXVlc3RJbmZvfWAsXG4gICAgICBgY29sb3I6JHtzdGF0dXNDb2xvcn1gLFxuICAgICAgYCR7cmVzcG9uc2UyLnN0YXR1c30gJHtyZXNwb25zZTIuc3RhdHVzVGV4dH1gLFxuICAgICAgXCJjb2xvcjppbmhlcml0XCJcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdDpcIiwgbG9nZ2VkUmVxdWVzdCk7XG4gICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCB0aGlzKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCBsb2dnZWRSZXNwb25zZSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9vblVuaGFuZGxlZFJlcXVlc3QudHNcbnZhciBNQVhfTUFUQ0hfU0NPUkUgPSAzO1xudmFyIE1BWF9TVUdHRVNUSU9OX0NPVU5UID0gNDtcbnZhciBUWVBFX01BVENIX0RFTFRBID0gMC41O1xuZnVuY3Rpb24gZ3JvdXBIYW5kbGVyc0J5VHlwZShoYW5kbGVycykge1xuICByZXR1cm4gaGFuZGxlcnMucmVkdWNlKFxuICAgIChncm91cHMsIGhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgUmVzdEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLnJlc3QucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgR3JhcGhRTEhhbmRsZXIpIHtcbiAgICAgICAgZ3JvdXBzLmdyYXBocWwucHVzaChoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcbiAgICB7XG4gICAgICByZXN0OiBbXSxcbiAgICAgIGdyYXBocWw6IFtdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzdEhhbmRsZXJTY29yZSgpIHtcbiAgcmV0dXJuIChyZXF1ZXN0LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyBwYXRoLCBtZXRob2QgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBtZXRob2QgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU1ldGhvZCA9IGlzU3RyaW5nRXF1YWwocmVxdWVzdC5tZXRob2QsIG1ldGhvZCk7XG4gICAgY29uc3QgbWV0aG9kU2NvcmVEZWx0YSA9IGhhc1NhbWVNZXRob2QgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCByZXF1ZXN0UHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3Qgc2NvcmUgPSAoMCwgaW1wb3J0X2pzX2xldmVuc2h0ZWluLmRlZmF1bHQpKHJlcXVlc3RQdWJsaWNVcmwsIHBhdGgpO1xuICAgIHJldHVybiBzY29yZSAtIG1ldGhvZFNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRHcmFwaFFMSGFuZGxlclNjb3JlKHBhcnNlZFF1ZXJ5KSB7XG4gIHJldHVybiAoXywgaGFuZGxlcikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBjb25zdCB7IG9wZXJhdGlvblR5cGUsIG9wZXJhdGlvbk5hbWUgfSA9IGhhbmRsZXIuaW5mbztcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbk5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgaGFzU2FtZU9wZXJhdGlvblR5cGUgPSBwYXJzZWRRdWVyeS5vcGVyYXRpb25UeXBlID09PSBvcGVyYXRpb25UeXBlO1xuICAgIGNvbnN0IG9wZXJhdGlvblR5cGVTY29yZURlbHRhID0gaGFzU2FtZU9wZXJhdGlvblR5cGUgPyBUWVBFX01BVENIX0RFTFRBIDogMDtcbiAgICBjb25zdCBzY29yZSA9ICgwLCBpbXBvcnRfanNfbGV2ZW5zaHRlaW4uZGVmYXVsdCkocGFyc2VkUXVlcnkub3BlcmF0aW9uTmFtZSwgb3BlcmF0aW9uTmFtZSk7XG4gICAgcmV0dXJuIHNjb3JlIC0gb3BlcmF0aW9uVHlwZVNjb3JlRGVsdGE7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRIYW5kbGVyKHJlcXVlc3QsIGhhbmRsZXJzLCBnZXRTY29yZSkge1xuICBjb25zdCBzdWdnZXN0ZWRIYW5kbGVycyA9IGhhbmRsZXJzLnJlZHVjZSgoc3VnZ2VzdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBzY29yZSA9IGdldFNjb3JlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgIHJldHVybiBzdWdnZXN0aW9ucy5jb25jYXQoW1tzY29yZSwgaGFuZGxlcl1dKTtcbiAgfSwgW10pLnNvcnQoKFtsZWZ0U2NvcmVdLCBbcmlnaHRTY29yZV0pID0+IGxlZnRTY29yZSAtIHJpZ2h0U2NvcmUpLmZpbHRlcigoW3Njb3JlXSkgPT4gc2NvcmUgPD0gTUFYX01BVENIX1NDT1JFKS5zbGljZSgwLCBNQVhfU1VHR0VTVElPTl9DT1VOVCkubWFwKChbLCBoYW5kbGVyXSkgPT4gaGFuZGxlcik7XG4gIHJldHVybiBzdWdnZXN0ZWRIYW5kbGVycztcbn1cbmZ1bmN0aW9uIGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShoYW5kbGVycykge1xuICBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBgRGlkIHlvdSBtZWFuIHRvIHJlcXVlc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVzb3VyY2VzIGluc3RlYWQ/XG5cbiR7aGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBgICBcXHUyMDIyICR7aGFuZGxlci5pbmZvLmhlYWRlcn1gKS5qb2luKFwiXFxuXCIpfWA7XG4gIH1cbiAgcmV0dXJuIGBEaWQgeW91IG1lYW4gdG8gcmVxdWVzdCBcIiR7aGFuZGxlcnNbMF0uaW5mby5oZWFkZXJ9XCIgaW5zdGVhZD9gO1xufVxuZnVuY3Rpb24gb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBzdHJhdGVneSA9IFwid2FyblwiKSB7XG4gIGNvbnN0IHBhcnNlZEdyYXBoUUxRdWVyeSA9IHRyeUNhdGNoKCgpID0+IHBhcnNlR3JhcGhRTFJlcXVlc3QocmVxdWVzdCkpO1xuICBmdW5jdGlvbiBnZW5lcmF0ZUhhbmRsZXJTdWdnZXN0aW9uKCkge1xuICAgIGNvbnN0IGhhbmRsZXJHcm91cHMgPSBncm91cEhhbmRsZXJzQnlUeXBlKGhhbmRsZXJzKTtcbiAgICBjb25zdCByZWxldmFudEhhbmRsZXJzID0gcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gaGFuZGxlckdyb3Vwcy5ncmFwaHFsIDogaGFuZGxlckdyb3Vwcy5yZXN0O1xuICAgIGNvbnN0IHN1Z2dlc3RlZEhhbmRsZXJzID0gZ2V0U3VnZ2VzdGVkSGFuZGxlcihcbiAgICAgIHJlcXVlc3QsXG4gICAgICByZWxldmFudEhhbmRsZXJzLFxuICAgICAgcGFyc2VkR3JhcGhRTFF1ZXJ5ID8gZ2V0R3JhcGhRTEhhbmRsZXJTY29yZShwYXJzZWRHcmFwaFFMUXVlcnkpIDogZ2V0UmVzdEhhbmRsZXJTY29yZSgpXG4gICAgKTtcbiAgICByZXR1cm4gc3VnZ2VzdGVkSGFuZGxlcnMubGVuZ3RoID4gMCA/IGdldFN1Z2dlc3RlZEhhbmRsZXJzTWVzc2FnZShzdWdnZXN0ZWRIYW5kbGVycykgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKSB7XG4gICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlciA9IHBhcnNlZEdyYXBoUUxRdWVyeSA/IGAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25UeXBlfSAke3BhcnNlZEdyYXBoUUxRdWVyeS5vcGVyYXRpb25OYW1lfSAoJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9KWAgOiBgJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9YDtcbiAgICBjb25zdCBoYW5kbGVyU3VnZ2VzdGlvbiA9IGdlbmVyYXRlSGFuZGxlclN1Z2dlc3Rpb24oKTtcbiAgICBjb25zdCBtZXNzYWdlVGVtcGxhdGUgPSBbXG4gICAgICBgY2FwdHVyZWQgYSByZXF1ZXN0IHdpdGhvdXQgYSBtYXRjaGluZyByZXF1ZXN0IGhhbmRsZXI6YCxcbiAgICAgIGAgIFxcdTIwMjIgJHtyZXF1ZXN0SGVhZGVyfWAsXG4gICAgICBoYW5kbGVyU3VnZ2VzdGlvbixcbiAgICAgIGBJZiB5b3Ugc3RpbGwgd2lzaCB0byBpbnRlcmNlcHQgdGhpcyB1bmhhbmRsZWQgcmVxdWVzdCwgcGxlYXNlIGNyZWF0ZSBhIHJlcXVlc3QgaGFuZGxlciBmb3IgaXQuXG5SZWFkIG1vcmU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9nZXR0aW5nLXN0YXJ0ZWQvbW9ja3NgXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5qb2luKFwiXFxuXFxuXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGdlbmVyYXRlVW5oYW5kbGVkUmVxdWVzdE1lc3NhZ2UoKTtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5Mikge1xuICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgZGV2VXRpbHMuZXJyb3IoXCJFcnJvcjogJXNcIiwgbWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgJ0Nhbm5vdCBieXBhc3MgYSByZXF1ZXN0IHdoZW4gdXNpbmcgdGhlIFwiZXJyb3JcIiBzdHJhdGVneSBmb3IgdGhlIFwib25VbmhhbmRsZWRSZXF1ZXN0XCIgb3B0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FyblwiOiB7XG4gICAgICAgIGRldlV0aWxzLndhcm4oXCJXYXJuaW5nOiAlc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYnlwYXNzXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHJlYWN0IHRvIGFuIHVuaGFuZGxlZCByZXF1ZXN0OiB1bmtub3duIHN0cmF0ZWd5IFwiJXNcIi4gUGxlYXNlIHByb3ZpZGUgb25lIG9mIHRoZSBzdXBwb3J0ZWQgc3RyYXRlZ2llcyAoXCJieXBhc3NcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIikgb3IgYSBjdXN0b20gY2FsbGJhY2sgZnVuY3Rpb24gYXMgdGhlIHZhbHVlIG9mIHRoZSBcIm9uVW5oYW5kbGVkUmVxdWVzdFwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgc3RyYXRlZ3kyXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdHJhdGVneShyZXF1ZXN0LCB7XG4gICAgICB3YXJuaW5nOiBhcHBseVN0cmF0ZWd5LmJpbmQobnVsbCwgXCJ3YXJuXCIpLFxuICAgICAgZXJyb3I6IGFwcGx5U3RyYXRlZ3kuYmluZChudWxsLCBcImVycm9yXCIpXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFwcGx5U3RyYXRlZ3koc3RyYXRlZ3kpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9yZWFkUmVzcG9uc2VDb29raWVzLnRzXG52YXIgaW1wb3J0X2Nvb2tpZXMyID0gcmVxdWlyZShcIkBtc3dqcy9jb29raWVzXCIpO1xuZnVuY3Rpb24gcmVhZFJlc3BvbnNlQ29va2llcyhyZXF1ZXN0LCByZXNwb25zZTIpIHtcbiAgaW1wb3J0X2Nvb2tpZXMyLnN0b3JlLmFkZCh7IC4uLnJlcXVlc3QsIHVybDogcmVxdWVzdC51cmwudG9TdHJpbmcoKSB9LCByZXNwb25zZTIpO1xuICBpbXBvcnRfY29va2llczIuc3RvcmUucGVyc2lzdCgpO1xufVxuXG4vLyBzcmMvdXRpbHMvaGFuZGxlUmVxdWVzdC50c1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0LCBoYW5kbGVycywgb3B0aW9ucywgZW1pdHRlciwgaGFuZGxlUmVxdWVzdE9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6c3RhcnRcIiwgcmVxdWVzdCk7XG4gIGlmIChyZXF1ZXN0LmhlYWRlcnMuZ2V0KFwieC1tc3ctYnlwYXNzXCIpID09PSBcInRydWVcIikge1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYSA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW2xvb2t1cEVycm9yLCBsb29rdXBSZXN1bHRdID0gYXdhaXQgKDAsIGltcG9ydF91bnRpbDIudW50aWwpKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0UmVzcG9uc2UoXG4gICAgICByZXF1ZXN0LFxuICAgICAgaGFuZGxlcnMsXG4gICAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMucmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICB9KTtcbiAgaWYgKGxvb2t1cEVycm9yKSB7XG4gICAgZW1pdHRlci5lbWl0KFwidW5oYW5kbGVkRXhjZXB0aW9uXCIsIGxvb2t1cEVycm9yLCByZXF1ZXN0KTtcbiAgICB0aHJvdyBsb29rdXBFcnJvcjtcbiAgfVxuICBjb25zdCB7IGhhbmRsZXIsIHJlc3BvbnNlOiByZXNwb25zZTIgfSA9IGxvb2t1cFJlc3VsdDtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgb25VbmhhbmRsZWRSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLm9uVW5oYW5kbGVkUmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDp1bmhhbmRsZWRcIiwgcmVxdWVzdCk7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9iID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXJlc3BvbnNlMikge1xuICAgIGRldlV0aWxzLndhcm4oXG4gICAgICBgRXhwZWN0ZWQgcmVzcG9uc2UgcmVzb2x2ZXIgdG8gcmV0dXJuIGEgbW9ja2VkIHJlc3BvbnNlIE9iamVjdCwgYnV0IGdvdCAlcy4gVGhlIG9yaWdpbmFsIHJlc3BvbnNlIGlzIGdvaW5nIHRvIGJlIHVzZWQgaW5zdGVhZC5cblxuICBcXHUyMDIyICVzXG4gICAgJXNgLFxuICAgICAgcmVzcG9uc2UyLFxuICAgICAgaGFuZGxlci5pbmZvLmhlYWRlcixcbiAgICAgIGhhbmRsZXIuaW5mby5jYWxsRnJhbWVcbiAgICApO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYyA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlMi5wYXNzdGhyb3VnaCkge1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfZCA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVhZFJlc3BvbnNlQ29va2llcyhyZXF1ZXN0LCByZXNwb25zZTIpO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0Om1hdGNoXCIsIHJlcXVlc3QpO1xuICBjb25zdCByZXF1aXJlZExvb2t1cFJlc3VsdCA9IGxvb2t1cFJlc3VsdDtcbiAgY29uc3QgdHJhbnNmb3JtZWRSZXNwb25zZSA9ICgoX2UgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXNwb25zZTIpKSB8fCByZXNwb25zZTI7XG4gIChfZiA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vbk1vY2tlZFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY2FsbChcbiAgICBoYW5kbGVSZXF1ZXN0T3B0aW9ucyxcbiAgICB0cmFuc2Zvcm1lZFJlc3BvbnNlLFxuICAgIHJlcXVpcmVkTG9va3VwUmVzdWx0XG4gICk7XG4gIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICByZXR1cm4gdHJhbnNmb3JtZWRSZXNwb25zZTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvc2VyaWFsaXplUmVzcG9uc2UudHNcbnZhciBpbXBvcnRfaGVhZGVyc19wb2x5ZmlsbDkgPSByZXF1aXJlKFwiaGVhZGVycy1wb2x5ZmlsbFwiKTtcbmFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlMikge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogcmVzcG9uc2UyLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiByZXNwb25zZTIuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiAoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw5LmZsYXR0ZW5IZWFkZXJzT2JqZWN0KSgoMCwgaW1wb3J0X2hlYWRlcnNfcG9seWZpbGw5LmhlYWRlcnNUb09iamVjdCkocmVzcG9uc2UyLmhlYWRlcnMpKSxcbiAgICBib2R5OiBhd2FpdCByZXNwb25zZTIuY2xvbmUoKS50ZXh0KClcbiAgfTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZVJlcXVlc3RMaXN0ZW5lci50c1xudmFyIGNyZWF0ZVJlcXVlc3RMaXN0ZW5lciA9IChjb250ZXh0LCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBhc3luYyAoZXZlbnQsIG1lc3NhZ2UpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWVzc2FnZUNoYW5uZWwgPSBuZXcgV29ya2VyQ2hhbm5lbChldmVudC5wb3J0c1swXSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHBhcnNlV29ya2VyUmVxdWVzdChtZXNzYWdlLnBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBoYW5kbGVSZXF1ZXN0KFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZXh0LnJlcXVlc3RIYW5kbGVycyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLFxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgb25QYXNzdGhyb3VnaFJlc3BvbnNlKCkge1xuICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXCJOT1RfRk9VTkRcIik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbk1vY2tlZFJlc3BvbnNlKHJlc3BvbnNlMiwgeyBoYW5kbGVyLCBwdWJsaWNSZXF1ZXN0LCBwYXJzZWRSZXF1ZXN0IH0pIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZTIuYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgYSBtb2NrZWQgcmVzcG9uc2Ugd2l0aCBhIFwiUmVhZGFibGVTdHJlYW1cIiBib2R5OiBtb2NrZWQgc3RyZWFtcyBhcmUgbm90IHN1cHBvcnRlZC4gRm9sbG93IGh0dHBzOi8vZ2l0aHViLmNvbS9tc3dqcy9tc3cvaXNzdWVzLzEzMzYgZm9yIG1vcmUgZGV0YWlscy4nXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VJbnN0YW5jZSA9IG5ldyBSZXNwb25zZShyZXNwb25zZTIuYm9keSwgcmVzcG9uc2UyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRm9yTG9ncyA9IHJlc3BvbnNlSW5zdGFuY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlSW5zdGFuY2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHJlc3BvbnNlMi5ib2R5ID09IG51bGwgPyBudWxsIDogcmVzcG9uc2VCb2R5QnVmZmVyO1xuICAgICAgICAgICAgbWVzc2FnZUNoYW5uZWwucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgIFwiTU9DS19SRVNQT05TRVwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UyLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQm9keVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbcmVzcG9uc2VCb2R5QnVmZmVyXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5xdWlldCkge1xuICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIub25jZShcInJlc3BvbnNlOm1vY2tlZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5sb2coXG4gICAgICAgICAgICAgICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgYXdhaXQgc2VyaWFsaXplUmVzcG9uc2UocmVzcG9uc2VGb3JMb2dzKSxcbiAgICAgICAgICAgICAgICAgIHBhcnNlZFJlcXVlc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgbmFtZTogZXJyb3IyLm5hbWUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IyLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBkZXZVdGlscy5lcnJvcihcbiAgICAgICAgICBgVW5jYXVnaHQgZXhjZXB0aW9uIGluIHRoZSByZXF1ZXN0IGhhbmRsZXIgZm9yIFwiJXMgJXNcIjpcblxuJXNcblxuVGhpcyBleGNlcHRpb24gaGFzIGJlZW4gZ3JhY2VmdWxseSBoYW5kbGVkIGFzIGEgNTAwIHJlc3BvbnNlLCBob3dldmVyLCBpdCdzIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHJlc29sdmUgdGhpcyBlcnJvciwgYXMgaXQgaW5kaWNhdGVzIGEgbWlzdGFrZSBpbiB5b3VyIGNvZGUuIElmIHlvdSB3aXNoIHRvIG1vY2sgYW4gZXJyb3IgcmVzcG9uc2UsIHBsZWFzZSBzZWUgdGhpcyBndWlkZTogaHR0cHM6Ly9tc3dqcy5pby9kb2NzL3JlY2lwZXMvbW9ja2luZy1lcnJvci1yZXNwb25zZXNgLFxuICAgICAgICAgIHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHJlcXVlc3QudXJsLFxuICAgICAgICAgIChfYSA9IGVycm9yMi5zdGFjaykgIT0gbnVsbCA/IF9hIDogZXJyb3IyXG4gICAgICAgICk7XG4gICAgICAgIG1lc3NhZ2VDaGFubmVsLnBvc3RNZXNzYWdlKFwiTU9DS19SRVNQT05TRVwiLCB7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgc3RhdHVzVGV4dDogXCJSZXF1ZXN0IEhhbmRsZXIgRXJyb3JcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IyLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvcjIubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvcjIuc3RhY2tcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UyKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiByZXNwb25zZTIuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlMi5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHJlc3BvbnNlMi5oZWFkZXJzLmFsbCgpLFxuICAgIGJvZHk6IHJlc3BvbnNlMi5ib2R5LFxuICAgIGRlbGF5OiByZXNwb25zZTIuZGVsYXlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3JlcXVlc3RJbnRlZ3JpdHlDaGVjay50c1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEludGVncml0eUNoZWNrKGNvbnRleHQsIHNlcnZpY2VXb3JrZXIpIHtcbiAgY29udGV4dC53b3JrZXJDaGFubmVsLnNlbmQoXCJJTlRFR1JJVFlfQ0hFQ0tfUkVRVUVTVFwiKTtcbiAgY29uc3QgeyBwYXlsb2FkOiBhY3R1YWxDaGVja3N1bSB9ID0gYXdhaXQgY29udGV4dC5ldmVudHMub25jZShcbiAgICBcIklOVEVHUklUWV9DSEVDS19SRVNQT05TRVwiXG4gICk7XG4gIGlmIChhY3R1YWxDaGVja3N1bSAhPT0gXCIzZDZiOWYwNjQxMGQxNzlhN2Y3NDA0ZDRiZjRjM2M3MFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEN1cnJlbnRseSBhY3RpdmUgU2VydmljZSBXb3JrZXIgKCR7YWN0dWFsQ2hlY2tzdW19KSBpcyBiZWhpbmQgdGhlIGxhdGVzdCBwdWJsaXNoZWQgb25lICgke1wiM2Q2YjlmMDY0MTBkMTc5YTdmNzQwNGQ0YmY0YzNjNzBcIn0pLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzZXJ2aWNlV29ya2VyO1xufVxuXG4vLyBzcmMvdXRpbHMvZGVmZXJOZXR3b3JrUmVxdWVzdHNVbnRpbC50c1xudmFyIGltcG9ydF91bnRpbDMgPSByZXF1aXJlKFwiQG9wZW4tZHJhZnQvdW50aWxcIik7XG5mdW5jdGlvbiBkZWZlck5ldHdvcmtSZXF1ZXN0c1VudGlsKHByZWRpY2F0ZVByb21pc2UpIHtcbiAgY29uc3Qgb3JpZ2luYWxYaHJTZW5kID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kO1xuICB3aW5kb3cuWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgKDAsIGltcG9ydF91bnRpbDMudW50aWwpKCgpID0+IHByZWRpY2F0ZVByb21pc2UpLnRoZW4oKCkgPT4ge1xuICAgICAgd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gb3JpZ2luYWxYaHJTZW5kO1xuICAgICAgdGhpcy5zZW5kKC4uLmFyZ3MpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBvcmlnaW5hbEZldGNoID0gd2luZG93LmZldGNoO1xuICB3aW5kb3cuZmV0Y2ggPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgIGF3YWl0ICgwLCBpbXBvcnRfdW50aWwzLnVudGlsKSgoKSA9PiBwcmVkaWNhdGVQcm9taXNlKTtcbiAgICB3aW5kb3cuZmV0Y2ggPSBvcmlnaW5hbEZldGNoO1xuICAgIHJldHVybiB3aW5kb3cuZmV0Y2goLi4uYXJncyk7XG4gIH07XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVSZXNwb25zZUxpc3RlbmVyLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUxpc3RlbmVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIChfLCBtZXNzYWdlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcGF5bG9hZDogcmVzcG9uc2VKc29uIH0gPSBtZXNzYWdlO1xuICAgIGlmICgoX2EgPSByZXNwb25zZUpzb24udHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwib3BhcXVlXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlMiA9IG5ldyBSZXNwb25zZShyZXNwb25zZUpzb24uYm9keSB8fCBudWxsLCByZXNwb25zZUpzb24pO1xuICAgIGNvbnN0IGlzTW9ja2VkUmVzcG9uc2UgPSByZXNwb25zZTIuaGVhZGVycy5nZXQoXCJ4LXBvd2VyZWQtYnlcIikgPT09IFwibXN3XCI7XG4gICAgaWYgKGlzTW9ja2VkUmVzcG9uc2UpIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6bW9ja2VkXCIsIHJlc3BvbnNlMiwgcmVzcG9uc2VKc29uLnJlcXVlc3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci5lbWl0KFwicmVzcG9uc2U6YnlwYXNzXCIsIHJlc3BvbnNlMiwgcmVzcG9uc2VKc29uLnJlcXVlc3RJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvdXRpbHMvdmFsaWRhdGVXb3JrZXJTY29wZS50c1xuZnVuY3Rpb24gdmFsaWRhdGVXb3JrZXJTY29wZShyZWdpc3RyYXRpb24sIG9wdGlvbnMpIHtcbiAgaWYgKCEob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5xdWlldCkgJiYgIWxvY2F0aW9uLmhyZWYuc3RhcnRzV2l0aChyZWdpc3RyYXRpb24uc2NvcGUpKSB7XG4gICAgZGV2VXRpbHMud2FybihcbiAgICAgIGBDYW5ub3QgaW50ZXJjZXB0IHJlcXVlc3RzIG9uIHRoaXMgcGFnZSBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgd29ya2VyJ3Mgc2NvcGUgKFwiJHtyZWdpc3RyYXRpb24uc2NvcGV9XCIpLiBJZiB5b3Ugd2lzaCB0byBtb2NrIEFQSSByZXF1ZXN0cyBvbiB0aGlzIHBhZ2UsIHlvdSBtdXN0IHJlc29sdmUgdGhpcyBzY29wZSBpc3N1ZS5cblxuLSAoUmVjb21tZW5kZWQpIFJlZ2lzdGVyIHRoZSB3b3JrZXIgYXQgdGhlIHJvb3QgbGV2ZWwgKFwiL1wiKSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuLSBTZXQgdGhlIFwiU2VydmljZS1Xb3JrZXItQWxsb3dlZFwiIHJlc3BvbnNlIGhlYWRlciB0byBhbGxvdyBvdXQtb2Ytc2NvcGUgd29ya2Vycy5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvc2V0dXBXb3JrZXIvc3RhcnQvY3JlYXRlU3RhcnRIYW5kbGVyLnRzXG52YXIgY3JlYXRlU3RhcnRIYW5kbGVyID0gKGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXJ0KG9wdGlvbnMsIGN1c3RvbU9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFydFdvcmtlckluc3RhbmNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29udGV4dC5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICBjb250ZXh0LndvcmtlckNoYW5uZWwub24oXG4gICAgICAgIFwiUkVRVUVTVFwiLFxuICAgICAgICBjcmVhdGVSZXF1ZXN0TGlzdGVuZXIoY29udGV4dCwgb3B0aW9ucylcbiAgICAgICk7XG4gICAgICBjb250ZXh0LndvcmtlckNoYW5uZWwub24oXCJSRVNQT05TRVwiLCBjcmVhdGVSZXNwb25zZUxpc3RlbmVyKGNvbnRleHQpKTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgZ2V0V29ya2VySW5zdGFuY2UoXG4gICAgICAgIG9wdGlvbnMuc2VydmljZVdvcmtlci51cmwsXG4gICAgICAgIG9wdGlvbnMuc2VydmljZVdvcmtlci5vcHRpb25zLFxuICAgICAgICBvcHRpb25zLmZpbmRXb3JrZXJcbiAgICAgICk7XG4gICAgICBjb25zdCBbd29ya2VyLCByZWdpc3RyYXRpb25dID0gaW5zdGFuY2U7XG4gICAgICBpZiAoIXdvcmtlcikge1xuICAgICAgICBjb25zdCBtaXNzaW5nV29ya2VyTWVzc2FnZSA9IChjdXN0b21PcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21PcHRpb25zLmZpbmRXb3JrZXIpID8gZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uIHVzaW5nIGEgY3VzdG9tIFwiZmluZFdvcmtlclwiIHByZWRpY2F0ZS5cblxuUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBjdXN0b20gcHJlZGljYXRlIHByb3Blcmx5IGxvY2F0ZXMgdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbiBhdCBcIiVzXCIuXG5Nb3JlIGRldGFpbHM6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9hcGkvc2V0dXAtd29ya2VyL3N0YXJ0I2ZpbmR3b3JrZXJcbmAsXG4gICAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLnVybFxuICAgICAgICApIDogZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSB0aGUgU2VydmljZSBXb3JrZXIgcmVnaXN0cmF0aW9uLlxuXG5UaGlzIG1vc3QgbGlrZWx5IG1lYW5zIHRoYXQgdGhlIHdvcmtlciBzY3JpcHQgVVJMIFwiJXNcIiBjYW5ub3QgcmVzb2x2ZSBhZ2FpbnN0IHRoZSBhY3R1YWwgcHVibGljIGhvc3RuYW1lICglcykuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3VyIGFwcGxpY2F0aW9uIHJ1bnMgYmVoaW5kIGEgcHJveHksIG9yIGhhcyBhIGR5bmFtaWMgaG9zdG5hbWUuXG5cblBsZWFzZSBjb25zaWRlciB1c2luZyBhIGN1c3RvbSBcInNlcnZpY2VXb3JrZXIudXJsXCIgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSBhY3R1YWwgd29ya2VyIHNjcmlwdCBsb2NhdGlvbiwgb3IgYSBjdXN0b20gXCJmaW5kV29ya2VyXCIgb3B0aW9uIHRvIHJlc29sdmUgdGhlIFNlcnZpY2UgV29ya2VyIHJlZ2lzdHJhdGlvbiBtYW51YWxseS4gTW9yZSBkZXRhaWxzOiBodHRwczovL21zd2pzLmlvL2RvY3MvYXBpL3NldHVwLXdvcmtlci9zdGFydGAsXG4gICAgICAgICAgb3B0aW9ucy5zZXJ2aWNlV29ya2VyLnVybCxcbiAgICAgICAgICBsb2NhdGlvbi5ob3N0XG4gICAgICAgICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtaXNzaW5nV29ya2VyTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LndvcmtlciA9IHdvcmtlcjtcbiAgICAgIGNvbnRleHQucmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uO1xuICAgICAgY29udGV4dC5ldmVudHMuYWRkTGlzdGVuZXIod2luZG93LCBcImJlZm9yZXVubG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh3b3JrZXIuc3RhdGUgIT09IFwicmVkdW5kYW50XCIpIHtcbiAgICAgICAgICBjb250ZXh0LndvcmtlckNoYW5uZWwuc2VuZChcIkNMSUVOVF9DTE9TRURcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoY29udGV4dC5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IFtpbnRlZ3JpdHlFcnJvcl0gPSBhd2FpdCAoMCwgaW1wb3J0X3VudGlsNC51bnRpbCkoXG4gICAgICAgICgpID0+IHJlcXVlc3RJbnRlZ3JpdHlDaGVjayhjb250ZXh0LCB3b3JrZXIpXG4gICAgICApO1xuICAgICAgaWYgKGludGVncml0eUVycm9yKSB7XG4gICAgICAgIGRldlV0aWxzLmVycm9yKGBEZXRlY3RlZCBvdXRkYXRlZCBTZXJ2aWNlIFdvcmtlcjogJHtpbnRlZ3JpdHlFcnJvci5tZXNzYWdlfVxuXG5UaGUgbW9ja2luZyBpcyBzdGlsbCBlbmFibGVkLCBidXQgaXQncyBoaWdobHkgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXBkYXRlIHlvdXIgU2VydmljZSBXb3JrZXIgYnkgcnVubmluZzpcblxuJCBucHggbXN3IGluaXQgPFBVQkxJQ19ESVI+XG5cblRoaXMgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IHRoZSBTZXJ2aWNlIFdvcmtlciBpcyBpbiBzeW5jIHdpdGggdGhlIGxpYnJhcnkgdG8gZ3VhcmFudGVlIGl0cyBzdGFiaWxpdHkuXG5JZiB0aGlzIG1lc3NhZ2Ugc3RpbGwgcGVyc2lzdHMgYWZ0ZXIgdXBkYXRpbmcsIHBsZWFzZSByZXBvcnQgYW4gaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLWRyYWZ0L21zdy9pc3N1ZXMgICAgICBgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXG4gICAgICAgICgpID0+IGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiS0VFUEFMSVZFX1JFUVVFU1RcIiksXG4gICAgICAgIDVlM1xuICAgICAgKTtcbiAgICAgIHZhbGlkYXRlV29ya2VyU2NvcGUocmVnaXN0cmF0aW9uLCBjb250ZXh0LnN0YXJ0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVnaXN0cmF0aW9uO1xuICAgIH07XG4gICAgY29uc3Qgd29ya2VyUmVnaXN0cmF0aW9uID0gc3RhcnRXb3JrZXJJbnN0YW5jZSgpLnRoZW4oXG4gICAgICBhc3luYyAocmVnaXN0cmF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdJbnN0YW5jZSA9IHJlZ2lzdHJhdGlvbi5pbnN0YWxsaW5nIHx8IHJlZ2lzdHJhdGlvbi53YWl0aW5nO1xuICAgICAgICBpZiAocGVuZGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmdJbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocGVuZGluZ0luc3RhbmNlLnN0YXRlID09PSBcImFjdGl2YXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5hYmxlTW9ja2luZyhjb250ZXh0LCBvcHRpb25zKS5jYXRjaCgoZXJyb3IyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZW5hYmxlIG1vY2tpbmc6ICR7ZXJyb3IyID09IG51bGwgPyB2b2lkIDAgOiBlcnJvcjIubWVzc2FnZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWdpc3RyYXRpb247XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAob3B0aW9ucy53YWl0VW50aWxSZWFkeSkge1xuICAgICAgZGVmZXJOZXR3b3JrUmVxdWVzdHNVbnRpbCh3b3JrZXJSZWdpc3RyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyUmVnaXN0cmF0aW9uO1xuICB9O1xufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3N0b3AvdXRpbHMvcHJpbnRTdG9wTWVzc2FnZS50c1xuZnVuY3Rpb24gcHJpbnRTdG9wTWVzc2FnZShhcmdzID0ge30pIHtcbiAgaWYgKGFyZ3MucXVpZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS5sb2coXG4gICAgYCVjJHtkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFwiTW9ja2luZyBkaXNhYmxlZC5cIil9YCxcbiAgICBcImNvbG9yOm9yYW5nZXJlZDtmb250LXdlaWdodDpib2xkO1wiXG4gICk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdG9wL2NyZWF0ZVN0b3AudHNcbnZhciBjcmVhdGVTdG9wID0gKGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY29udGV4dC5pc01vY2tpbmdFbmFibGVkKSB7XG4gICAgICBkZXZVdGlscy53YXJuKFxuICAgICAgICAnRm91bmQgYSByZWR1bmRhbnQgXCJ3b3JrZXIuc3RvcCgpXCIgY2FsbC4gTm90ZSB0aGF0IHN0b3BwaW5nIHRoZSB3b3JrZXIgd2hpbGUgbW9ja2luZyBhbHJlYWR5IHN0b3BwZWQgaGFzIG5vIGVmZmVjdC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBcIndvcmtlci5zdG9wKClcIiBjYWxsLidcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQud29ya2VyQ2hhbm5lbC5zZW5kKFwiTU9DS19ERUFDVElWQVRFXCIpO1xuICAgIGNvbnRleHQuaXNNb2NraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKGNvbnRleHQua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgIHByaW50U3RvcE1lc3NhZ2UoeyBxdWlldDogKF9hID0gY29udGV4dC5zdGFydE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5xdWlldCB9KTtcbiAgfTtcbn07XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC91dGlscy9wcmVwYXJlU3RhcnRIYW5kbGVyLnRzXG52YXIgREVGQVVMVF9TVEFSVF9PUFRJT05TID0ge1xuICBzZXJ2aWNlV29ya2VyOiB7XG4gICAgdXJsOiBcIi9tb2NrU2VydmljZVdvcmtlci5qc1wiLFxuICAgIG9wdGlvbnM6IG51bGxcbiAgfSxcbiAgcXVpZXQ6IGZhbHNlLFxuICB3YWl0VW50aWxSZWFkeTogdHJ1ZSxcbiAgb25VbmhhbmRsZWRSZXF1ZXN0OiBcIndhcm5cIixcbiAgZmluZFdvcmtlcihzY3JpcHRVUkwsIG1vY2tTZXJ2aWNlV29ya2VyVXJsKSB7XG4gICAgcmV0dXJuIHNjcmlwdFVSTCA9PT0gbW9ja1NlcnZpY2VXb3JrZXJVcmw7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lci50c1xudmFyIGltcG9ydF9pbnRlcmNlcHRvcnMzID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIik7XG52YXIgaW1wb3J0X2ZldGNoMyA9IHJlcXVpcmUoXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi9pbnRlcmNlcHRvcnMvZmV0Y2hcIik7XG52YXIgaW1wb3J0X1hNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZShcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL2ludGVyY2VwdG9ycy9YTUxIdHRwUmVxdWVzdFwiKTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvY3JlYXRlUmVzcG9uc2VGcm9tSXNvbW9ycGhpY1Jlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUZyb21Jc29tb3JwaGljUmVzcG9uc2UocmVzcG9uc2UyKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2UyLmJvZHksIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzcG9uc2UyLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcmVzcG9uc2UyLmhlYWRlcnNcbiAgfSk7XG59XG5cbi8vIHNyYy9zZXR1cFdvcmtlci9zdGFydC9jcmVhdGVGYWxsYmFja1JlcXVlc3RMaXN0ZW5lci50c1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tSZXF1ZXN0TGlzdGVuZXIoY29udGV4dCwgb3B0aW9ucykge1xuICBjb25zdCBpbnRlcmNlcHRvciA9IG5ldyBpbXBvcnRfaW50ZXJjZXB0b3JzMy5CYXRjaEludGVyY2VwdG9yKHtcbiAgICBuYW1lOiBcImZhbGxiYWNrXCIsXG4gICAgaW50ZXJjZXB0b3JzOiBbbmV3IGltcG9ydF9mZXRjaDMuRmV0Y2hJbnRlcmNlcHRvcigpLCBuZXcgaW1wb3J0X1hNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0SW50ZXJjZXB0b3IoKV1cbiAgfSk7XG4gIGludGVyY2VwdG9yLm9uKFwicmVxdWVzdFwiLCBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IG1vY2tlZFJlcXVlc3QgPSBuZXcgTW9ja2VkUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIGJvZHk6IGF3YWl0IHJlcXVlc3QuYXJyYXlCdWZmZXIoKVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGhhbmRsZVJlcXVlc3QoXG4gICAgICBtb2NrZWRSZXF1ZXN0LFxuICAgICAgY29udGV4dC5yZXF1ZXN0SGFuZGxlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgY29udGV4dC5lbWl0dGVyLFxuICAgICAge1xuICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZTMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZTMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2UzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZTMuaGVhZGVycy5hbGwoKSxcbiAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlMy5ib2R5LFxuICAgICAgICAgICAgZGVsYXk6IHJlc3BvbnNlMy5kZWxheVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW9ja2VkUmVzcG9uc2UoXywgeyBoYW5kbGVyLCBwdWJsaWNSZXF1ZXN0LCBwYXJzZWRSZXF1ZXN0IH0pIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMucXVpZXQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci5vbmNlKFwicmVzcG9uc2U6bW9ja2VkXCIsIGFzeW5jIChyZXNwb25zZTMpID0+IHtcbiAgICAgICAgICAgICAgaGFuZGxlci5sb2coXG4gICAgICAgICAgICAgICAgcHVibGljUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXJpYWxpemVSZXNwb25zZShyZXNwb25zZTMpLFxuICAgICAgICAgICAgICAgIHBhcnNlZFJlcXVlc3RcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlc3BvbnNlMikge1xuICAgICAgcmVxdWVzdC5yZXNwb25kV2l0aChyZXNwb25zZTIpO1xuICAgIH1cbiAgfSk7XG4gIGludGVyY2VwdG9yLm9uKFwicmVzcG9uc2VcIiwgKHJlcXVlc3QsIHJlc3BvbnNlMikgPT4ge1xuICAgIGlmICghcmVxdWVzdC5pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBicm93c2VyUmVzcG9uc2UgPSBjcmVhdGVSZXNwb25zZUZyb21Jc29tb3JwaGljUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBpZiAocmVzcG9uc2UyLmhlYWRlcnMuZ2V0KFwieC1wb3dlcmVkLWJ5XCIpID09PSBcIm1zd1wiKSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOm1vY2tlZFwiLCBicm93c2VyUmVzcG9uc2UsIHJlcXVlc3QuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOmJ5cGFzc1wiLCBicm93c2VyUmVzcG9uc2UsIHJlcXVlc3QuaWQpO1xuICAgIH1cbiAgfSk7XG4gIGludGVyY2VwdG9yLmFwcGx5KCk7XG4gIHJldHVybiBpbnRlcmNlcHRvcjtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0YXJ0L2NyZWF0ZUZhbGxiYWNrU3RhcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUZhbGxiYWNrU3RhcnQoY29udGV4dCkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gc3RhcnQob3B0aW9ucykge1xuICAgIGNvbnRleHQuZmFsbGJhY2tJbnRlcmNlcHRvciA9IGNyZWF0ZUZhbGxiYWNrUmVxdWVzdExpc3RlbmVyKFxuICAgICAgY29udGV4dCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHByaW50U3RhcnRNZXNzYWdlKHtcbiAgICAgIG1lc3NhZ2U6IFwiTW9ja2luZyBlbmFibGVkIChmYWxsYmFjayBtb2RlKS5cIixcbiAgICAgIHF1aWV0OiBvcHRpb25zLnF1aWV0XG4gICAgfSk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcbn1cblxuLy8gc3JjL3NldHVwV29ya2VyL3N0b3AvY3JlYXRlRmFsbGJhY2tTdG9wLnRzXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja1N0b3AoY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IGNvbnRleHQuZmFsbGJhY2tJbnRlcmNlcHRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICBwcmludFN0b3BNZXNzYWdlKHsgcXVpZXQ6IChfYiA9IGNvbnRleHQuc3RhcnRPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IucXVpZXQgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9TZXR1cEFwaS50c1xudmFyIGltcG9ydF9vdXR2YXJpYW50NCA9IHJlcXVpcmUoXCJvdXR2YXJpYW50XCIpO1xudmFyIGltcG9ydF9zdHJpY3RfZXZlbnRfZW1pdHRlciA9IHJlcXVpcmUoXCJzdHJpY3QtZXZlbnQtZW1pdHRlclwiKTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BpcGVFdmVudHMudHNcbmZ1bmN0aW9uIHBpcGVFdmVudHMoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCByYXdFbWl0ID0gc291cmNlLmVtaXQ7XG4gIGlmIChyYXdFbWl0Ll9pc1BpcGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNvdXJjZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQsIC4uLmRhdGEyKSB7XG4gICAgZGVzdGluYXRpb24uZW1pdChldmVudCwgLi4uZGF0YTIpO1xuICAgIHJldHVybiByYXdFbWl0LmNhbGwodGhpcywgZXZlbnQsIC4uLmRhdGEyKTtcbiAgfTtcbiAgc291cmNlLmVtaXQuX2lzUGlwZWQgPSB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvdG9SZWFkb25seUFycmF5LnRzXG5mdW5jdGlvbiB0b1JlYWRvbmx5QXJyYXkoc291cmNlKSB7XG4gIGNvbnN0IGNsb25lID0gWy4uLnNvdXJjZV07XG4gIE9iamVjdC5mcmVlemUoY2xvbmUpO1xuICByZXR1cm4gY2xvbmU7XG59XG5cbi8vIHNyYy9TZXR1cEFwaS50c1xudmFyIFNldHVwQXBpID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5pbml0aWFsSGFuZGxlcnMpIHtcbiAgICB0aGlzLnZhbGlkYXRlSGFuZGxlcnMoLi4uaW5pdGlhbEhhbmRsZXJzKTtcbiAgICB0aGlzLmluaXRpYWxIYW5kbGVycyA9IHRvUmVhZG9ubHlBcnJheShpbml0aWFsSGFuZGxlcnMpO1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzID0gWy4uLmluaXRpYWxIYW5kbGVyc107XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IGltcG9ydF9zdHJpY3RfZXZlbnRfZW1pdHRlci5FbWl0dGVyKCk7XG4gICAgdGhpcy5wdWJsaWNFbWl0dGVyID0gbmV3IGltcG9ydF9zdHJpY3RfZXZlbnRfZW1pdHRlci5FbWl0dGVyKCk7XG4gICAgcGlwZUV2ZW50cyh0aGlzLmVtaXR0ZXIsIHRoaXMucHVibGljRW1pdHRlcik7XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLmNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpO1xuICB9XG4gIHZhbGlkYXRlSGFuZGxlcnMoLi4uaGFuZGxlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICgwLCBpbXBvcnRfb3V0dmFyaWFudDQuaW52YXJpYW50KShcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoaGFuZGxlciksXG4gICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXCIlc1wiIGdpdmVuIGFuIEFycmF5IG9mIHJlcXVlc3QgaGFuZGxlcnMuIE1ha2Ugc3VyZSB5b3Ugc3ByZWFkIHRoZSByZXF1ZXN0IGhhbmRsZXJzIHdoZW4gY2FsbGluZyB0aGUgcmVzcGVjdGl2ZSBzZXR1cCBmdW5jdGlvbi4nXG4gICAgICAgICksXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IubmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIHVzZSguLi5ydW50aW1lSGFuZGxlcnMpIHtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycy51bnNoaWZ0KC4uLnJ1bnRpbWVIYW5kbGVycyk7XG4gIH1cbiAgcmVzdG9yZUhhbmRsZXJzKCkge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZChmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRIYW5kbGVycyguLi5uZXh0SGFuZGxlcnMpIHtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyA9IG5leHRIYW5kbGVycy5sZW5ndGggPiAwID8gWy4uLm5leHRIYW5kbGVyc10gOiBbLi4udGhpcy5pbml0aWFsSGFuZGxlcnNdO1xuICB9XG4gIGxpc3RIYW5kbGVycygpIHtcbiAgICByZXR1cm4gdG9SZWFkb25seUFycmF5KHRoaXMuY3VycmVudEhhbmRsZXJzKTtcbiAgfVxuICBjcmVhdGVMaWZlQ3ljbGVFdmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLm9uKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljRW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoLi4uYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3NldHVwV29ya2VyL3NldHVwV29ya2VyLnRzXG52YXIgU2V0dXBXb3JrZXJBcGkgPSBjbGFzcyBleHRlbmRzIFNldHVwQXBpIHtcbiAgY29uc3RydWN0b3IoLi4uaGFuZGxlcnMpIHtcbiAgICBzdXBlciguLi5oYW5kbGVycyk7XG4gICAgdGhpcy5zdGFydEhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMuc3RvcEhhbmRsZXIgPSBudWxsO1xuICAgICgwLCBpbXBvcnRfb3V0dmFyaWFudDUuaW52YXJpYW50KShcbiAgICAgICEoMCwgaW1wb3J0X2lzX25vZGVfcHJvY2VzczMuaXNOb2RlUHJvY2VzcykoKSxcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgYHNldHVwV29ya2VyYCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBDb25zaWRlciB1c2luZyBgc2V0dXBTZXJ2ZXJgIGZvciBOb2RlLmpzIGVudmlyb25tZW50IGluc3RlYWQuXCJcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jcmVhdGVXb3JrZXJDb250ZXh0KCk7XG4gIH1cbiAgY3JlYXRlV29ya2VyQ29udGV4dCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgaXNNb2NraW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICBzdGFydE9wdGlvbnM6IG51bGwsXG4gICAgICB3b3JrZXI6IG51bGwsXG4gICAgICByZWdpc3RyYXRpb246IG51bGwsXG4gICAgICByZXF1ZXN0SGFuZGxlcnM6IHRoaXMuY3VycmVudEhhbmRsZXJzLFxuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgd29ya2VyQ2hhbm5lbDoge1xuICAgICAgICBvbjogKGV2ZW50VHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRzLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIsXG4gICAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlICE9PSB0aGlzLmNvbnRleHQud29ya2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZDogKHR5cGUpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gdGhpcy5jb250ZXh0LndvcmtlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBvc3RNZXNzYWdlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGFkZExpc3RlbmVyOiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaCh7IGV2ZW50VHlwZSwgdGFyZ2V0LCBjYWxsYmFjayB9KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjayB9IG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZTogKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gW107XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUluY29taW5nTWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcjIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYmluZGluZ3MucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmV2ZW50cy5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcixcbiAgICAgICAgICAgICAgICBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBoYW5kbGVJbmNvbWluZ01lc3NhZ2VcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmV2ZW50cy5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlcixcbiAgICAgICAgICAgICAgICBcIm1lc3NhZ2VlcnJvclwiLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgYmluZGluZ3MuZm9yRWFjaCgodW5iaW5kKSA9PiB1bmJpbmQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VGYWxsYmFja01vZGU6ICEoXCJzZXJ2aWNlV29ya2VyXCIgaW4gbmF2aWdhdG9yKSB8fCBsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJmaWxlOlwiXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb250ZXh0LCB7XG4gICAgICByZXF1ZXN0SGFuZGxlcnM6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLmN1cnJlbnRIYW5kbGVyc1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhcnRIYW5kbGVyID0gY29udGV4dC51c2VGYWxsYmFja01vZGUgPyBjcmVhdGVGYWxsYmFja1N0YXJ0KGNvbnRleHQpIDogY3JlYXRlU3RhcnRIYW5kbGVyKGNvbnRleHQpO1xuICAgIHRoaXMuc3RvcEhhbmRsZXIgPSBjb250ZXh0LnVzZUZhbGxiYWNrTW9kZSA/IGNyZWF0ZUZhbGxiYWNrU3RvcChjb250ZXh0KSA6IGNyZWF0ZVN0b3AoY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgYXN5bmMgc3RhcnQob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb250ZXh0LnN0YXJ0T3B0aW9ucyA9IG1lcmdlUmlnaHQoXG4gICAgICBERUZBVUxUX1NUQVJUX09QVElPTlMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zdGFydEhhbmRsZXIodGhpcy5jb250ZXh0LnN0YXJ0T3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgcHJpbnRIYW5kbGVycygpIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMubGlzdEhhbmRsZXJzKCk7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgY29uc3QgeyBoZWFkZXIsIGNhbGxGcmFtZSB9ID0gaGFuZGxlci5pbmZvO1xuICAgICAgY29uc3QgcHJhZ21hID0gaGFuZGxlci5pbmZvLmhhc093blByb3BlcnR5KFwib3BlcmF0aW9uVHlwZVwiKSA/IFwiW2dyYXBocWxdXCIgOiBcIltyZXN0XVwiO1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgJHtwcmFnbWF9ICR7aGVhZGVyfWApO1xuICAgICAgaWYgKGNhbGxGcmFtZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRGVjbGFyYXRpb246ICR7Y2FsbEZyYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coXCJIYW5kbGVyOlwiLCBoYW5kbGVyKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9KTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmNvbnRleHQuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuY29udGV4dC5lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuc3RvcEhhbmRsZXIoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldHVwV29ya2VyKC4uLmhhbmRsZXJzKSB7XG4gIHJldHVybiBuZXcgU2V0dXBXb3JrZXJBcGkoLi4uaGFuZGxlcnMpO1xufVxuXG4vLyBzcmMvcmVzdC50c1xuZnVuY3Rpb24gY3JlYXRlUmVzdEhhbmRsZXIobWV0aG9kKSB7XG4gIHJldHVybiAocGF0aCwgcmVzb2x2ZXIpID0+IHtcbiAgICByZXR1cm4gbmV3IFJlc3RIYW5kbGVyKG1ldGhvZCwgcGF0aCwgcmVzb2x2ZXIpO1xuICB9O1xufVxudmFyIHJlc3QgPSB7XG4gIGFsbDogY3JlYXRlUmVzdEhhbmRsZXIoLy4rLyksXG4gIGhlYWQ6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiSEVBRFwiIC8qIEhFQUQgKi8pLFxuICBnZXQ6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiR0VUXCIgLyogR0VUICovKSxcbiAgcG9zdDogY3JlYXRlUmVzdEhhbmRsZXIoXCJQT1NUXCIgLyogUE9TVCAqLyksXG4gIHB1dDogY3JlYXRlUmVzdEhhbmRsZXIoXCJQVVRcIiAvKiBQVVQgKi8pLFxuICBkZWxldGU6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiREVMRVRFXCIgLyogREVMRVRFICovKSxcbiAgcGF0Y2g6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiUEFUQ0hcIiAvKiBQQVRDSCAqLyksXG4gIG9wdGlvbnM6IGNyZWF0ZVJlc3RIYW5kbGVyKFwiT1BUSU9OU1wiIC8qIE9QVElPTlMgKi8pXG59O1xuXG4vLyBzcmMvZ3JhcGhxbC50c1xuZnVuY3Rpb24gY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIob3BlcmF0aW9uVHlwZSwgdXJsKSB7XG4gIHJldHVybiAob3BlcmF0aW9uTmFtZSwgcmVzb2x2ZXIpID0+IHtcbiAgICByZXR1cm4gbmV3IEdyYXBoUUxIYW5kbGVyKFxuICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgIG9wZXJhdGlvbk5hbWUsXG4gICAgICB1cmwsXG4gICAgICByZXNvbHZlclxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHcmFwaFFMT3BlcmF0aW9uSGFuZGxlcih1cmwpIHtcbiAgcmV0dXJuIChyZXNvbHZlcikgPT4ge1xuICAgIHJldHVybiBuZXcgR3JhcGhRTEhhbmRsZXIoXG4gICAgICBcImFsbFwiLFxuICAgICAgbmV3IFJlZ0V4cChcIi4qXCIpLFxuICAgICAgdXJsLFxuICAgICAgcmVzb2x2ZXJcbiAgICApO1xuICB9O1xufVxudmFyIHN0YW5kYXJkR3JhcGhRTEhhbmRsZXJzID0ge1xuICBvcGVyYXRpb246IGNyZWF0ZUdyYXBoUUxPcGVyYXRpb25IYW5kbGVyKFwiKlwiKSxcbiAgcXVlcnk6IGNyZWF0ZVNjb3BlZEdyYXBoUUxIYW5kbGVyKFwicXVlcnlcIiwgXCIqXCIpLFxuICBtdXRhdGlvbjogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJtdXRhdGlvblwiLCBcIipcIilcbn07XG5mdW5jdGlvbiBjcmVhdGVHcmFwaFFMTGluayh1cmwpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb246IGNyZWF0ZUdyYXBoUUxPcGVyYXRpb25IYW5kbGVyKHVybCksXG4gICAgcXVlcnk6IGNyZWF0ZVNjb3BlZEdyYXBoUUxIYW5kbGVyKFwicXVlcnlcIiwgdXJsKSxcbiAgICBtdXRhdGlvbjogY3JlYXRlU2NvcGVkR3JhcGhRTEhhbmRsZXIoXCJtdXRhdGlvblwiLCB1cmwpXG4gIH07XG59XG52YXIgZ3JhcGhxbCA9IHtcbiAgLi4uc3RhbmRhcmRHcmFwaFFMSGFuZGxlcnMsXG4gIGxpbms6IGNyZWF0ZUdyYXBoUUxMaW5rXG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmNoZWNrR2xvYmFscygpO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoUUxIYW5kbGVyLFxuICBNb2NrZWRSZXF1ZXN0LFxuICBSRVNUTWV0aG9kcyxcbiAgUmVxdWVzdEhhbmRsZXIsXG4gIFJlc3RIYW5kbGVyLFxuICBTZXR1cEFwaSxcbiAgU2V0dXBXb3JrZXJBcGksXG4gIGNsZWFuVXJsLFxuICBjb21wb3NlLFxuICBjb250ZXh0LFxuICBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uLFxuICBkZWZhdWx0Q29udGV4dCxcbiAgZGVmYXVsdFJlc3BvbnNlLFxuICBncmFwaHFsLFxuICBncmFwaHFsQ29udGV4dCxcbiAgaGFuZGxlUmVxdWVzdCxcbiAgbWF0Y2hSZXF1ZXN0VXJsLFxuICByZXNwb25zZSxcbiAgcmVzdCxcbiAgcmVzdENvbnRleHQsXG4gIHNldHVwV29ya2VyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/msw/lib/index.js\n',
      );

      /***/
    },

  /***/ '(ssr)/./node_modules/msw/lib/node/index.mjs':
    /*!*********************************************!*\
  !*** ./node_modules/msw/lib/node/index.mjs ***!
  \*********************************************/
    /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __webpack_require__,
    ) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SetupServerApi: () => (/* binding */ SetupServerApi),\n/* harmony export */   setupServer: () => (/* binding */ setupServer)\n/* harmony export */ });\n/* harmony import */ var timers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timers */ "timers");\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chalk */ "(ssr)/./node_modules/chalk/source/index.js");\n/* harmony import */ var outvariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! outvariant */ "(ssr)/./node_modules/outvariant/lib/index.mjs");\n/* harmony import */ var _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mswjs/interceptors */ "(ssr)/./node_modules/@mswjs/interceptors/lib/index.js");\n/* harmony import */ var strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! strict-event-emitter */ "(ssr)/./node_modules/strict-event-emitter/lib/index.js");\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cookie */ "(ssr)/./node_modules/cookie/index.js");\n/* harmony import */ var _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mswjs/cookies */ "(ssr)/./node_modules/@mswjs/cookies/lib/index.js");\n/* harmony import */ var _mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/bufferUtils.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/utils/bufferUtils.js");\n/* harmony import */ var headers_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! headers-polyfill */ "(ssr)/./node_modules/headers-polyfill/lib/index.mjs");\n/* harmony import */ var _open_draft_until__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @open-draft/until */ "(ssr)/./node_modules/@open-draft/until/lib/index.js");\n/* harmony import */ var js_levenshtein__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! js-levenshtein */ "(ssr)/./node_modules/js-levenshtein/index.js");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! graphql */ "(ssr)/./node_modules/graphql/index.js");\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! is-node-process */ "(ssr)/./node_modules/is-node-process/lib/index.mjs");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! path-to-regexp */ "(ssr)/./node_modules/path-to-regexp/dist/index.js");\n/* harmony import */ var _mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @mswjs/interceptors/lib/utils/getCleanUrl.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/utils/getCleanUrl.js");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/ClientRequest/index.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/interceptors/ClientRequest/index.js");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js");\n/* harmony import */ var _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mswjs/interceptors/lib/interceptors/fetch/index.js */ "(ssr)/./node_modules/@mswjs/interceptors/lib/interceptors/fetch/index.js");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== "undefined")\n    return require.apply(this, arguments);\n  throw new Error(\'Dynamic require of "\' + x + \'" is not supported\');\n});\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// config/polyfills-node.ts\n\nvar setTimeout = timers__WEBPACK_IMPORTED_MODULE_0__.setTimeout;\n\n// src/node/SetupServerApi.ts\n\n\n\n\n// src/SetupApi.ts\n\n\n\n// src/utils/internal/devUtils.ts\n\nvar LIBRARY_PREFIX = "[MSW]";\nfunction formatMessage(message, ...positionals) {\n  const interpolatedMessage = (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message, ...positionals) {\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message, ...positionals) {\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function(event, ...data2) {\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor(...initialHandlers) {\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    this.publicEmitter = new strict_event_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers(...handlers) {\n    for (const handler of handlers) {\n      (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          \'Failed to construct "%s" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.\'\n        ),\n        this.constructor.name\n      );\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use(...runtimeHandlers) {\n    this.currentHandlers.unshift(...runtimeHandlers);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers(...nextHandlers) {\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args);\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args);\n      },\n      removeAllListeners: (...args) => {\n        return this.publicEmitter.removeAllListeners(...args);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === "object" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\n\n\n\n\n\n\n// src/utils/request/getRequestCookies.ts\n\nfunction getAllCookies() {\n  return cookie__WEBPACK_IMPORTED_MODULE_5__.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === "undefined" || typeof location === "undefined") {\n    return {};\n  }\n  switch (request.credentials) {\n    case "same-origin": {\n      return location.origin === request.url.origin ? getAllCookies() : {};\n    }\n    case "include": {\n      return getAllCookies();\n    }\n    default: {\n      return {};\n    }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.stringToHeaders)(headersString);\n  const contentType = headers.get("content-type") || "text/plain";\n  const disposition = headers.get("content-disposition");\n  if (!disposition) {\n    throw new Error(\'"Content-Disposition" header is required.\');\n  }\n  const directives = disposition.split(";").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split("=");\n    acc[name2] = rest.join("=");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get("content-type");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith("boundary=")).map((s) => s.replace(/^boundary=/, ""))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter((chunk) => chunk.startsWith("\\r\\n") && chunk.endsWith("\\r\\n")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ""));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split("\\r\\n\\r\\n");\n      const contentBody = rest.join("\\r\\n\\r\\n");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get("content-type")) == null ? void 0 : _a.toLowerCase()) || "";\n  const hasMultipartContent = contentType.startsWith("multipart/form-data");\n  if (hasMultipartContent && typeof body2 !== "object") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes("json");\n  if (hasJsonContent && typeof body2 !== "object") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.IsomorphicRequest {\n  constructor(url, init = {}) {\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || "default";\n    this.destination = init.destination || "";\n    this.integrity = init.integrity || "";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || "cors";\n    this.priority = init.priority || "auto";\n    this.redirect = init.redirect || "follow";\n    this.referrer = init.referrer || "";\n    this.referrerPolicy = init.referrerPolicy || "no-referrer";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0,_mswjs_interceptors_lib_utils_bufferUtils_js__WEBPACK_IMPORTED_MODULE_7__.decodeBuffer)(this["_body"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, "GET") && body2 === "") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: "Continue",\n      headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get("cookie");\n    const ownCookies = requestCookiesString ? cookie__WEBPACK_IMPORTED_MODULE_5__.parse(requestCookiesString) : {};\n    _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.hydrate();\n    const cookiesFromStore = Array.from(\n      (_a = _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.get({ ...this, url: this.url.href })) == null ? void 0 : _a.entries()\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore\n    };\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append("cookie", `${name}=${value}`);\n    }\n    return {\n      ...forwardedCookies,\n      ...ownCookies\n    };\n  }\n};\n\n// src/utils/handleRequest.ts\n\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\n\n\n// src/utils/internal/parseGraphQLRequest.ts\n\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = (request) => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(\n    request.url.pathname,\n    `${request.url.protocol}//${request.url.host}`\n  ).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === "OperationDefinition";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0,graphql__WEBPACK_IMPORTED_MODULE_11__.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = { variables };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key \'${key}\' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(".").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property \'${paths}\' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case "GET": {\n      const query = request.url.searchParams.get("query");\n      const variables = request.url.searchParams.get("variables") || "";\n      return {\n        query,\n        variables: jsonParse(variables)\n      };\n    }\n    case "POST": {\n      if ((_a = request.body) == null ? void 0 : _a.query) {\n        const { query, variables } = request.body;\n        return {\n          query,\n          variables\n        };\n      }\n      if ((_b = request.body) == null ? void 0 : _b.operations) {\n        const { operations, map, ...files } = request.body;\n        const parsedOperations = jsonParse(\n          operations\n        ) || {};\n        if (!parsedOperations.query) {\n          return null;\n        }\n        const parsedMap = jsonParse(map || "") || {};\n        const variables = parsedOperations.variables ? extractMultipartVariables(\n          parsedOperations.variables,\n          parsedMap,\n          files\n        ) : {};\n        return {\n          query: parsedOperations.query,\n          variables\n        };\n      }\n    }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const { query, variables } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(\n      devUtils.formatMessage(\n        \'Failed to intercept a GraphQL request to "%s %s": cannot parse query. See the error message from the parser below.\\n\\n%s\',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message\n      )\n    );\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json\nvar codes_default = {\n  "100": "Continue",\n  "101": "Switching Protocols",\n  "102": "Processing",\n  "103": "Early Hints",\n  "200": "OK",\n  "201": "Created",\n  "202": "Accepted",\n  "203": "Non-Authoritative Information",\n  "204": "No Content",\n  "205": "Reset Content",\n  "206": "Partial Content",\n  "207": "Multi-Status",\n  "208": "Already Reported",\n  "226": "IM Used",\n  "300": "Multiple Choices",\n  "301": "Moved Permanently",\n  "302": "Found",\n  "303": "See Other",\n  "304": "Not Modified",\n  "305": "Use Proxy",\n  "307": "Temporary Redirect",\n  "308": "Permanent Redirect",\n  "400": "Bad Request",\n  "401": "Unauthorized",\n  "402": "Payment Required",\n  "403": "Forbidden",\n  "404": "Not Found",\n  "405": "Method Not Allowed",\n  "406": "Not Acceptable",\n  "407": "Proxy Authentication Required",\n  "408": "Request Timeout",\n  "409": "Conflict",\n  "410": "Gone",\n  "411": "Length Required",\n  "412": "Precondition Failed",\n  "413": "Payload Too Large",\n  "414": "URI Too Long",\n  "415": "Unsupported Media Type",\n  "416": "Range Not Satisfiable",\n  "417": "Expectation Failed",\n  "418": "I\'m a Teapot",\n  "421": "Misdirected Request",\n  "422": "Unprocessable Entity",\n  "423": "Locked",\n  "424": "Failed Dependency",\n  "425": "Too Early",\n  "426": "Upgrade Required",\n  "428": "Precondition Required",\n  "429": "Too Many Requests",\n  "431": "Request Header Fields Too Large",\n  "451": "Unavailable For Legal Reasons",\n  "500": "Internal Server Error",\n  "501": "Not Implemented",\n  "502": "Bad Gateway",\n  "503": "Service Unavailable",\n  "504": "Gateway Timeout",\n  "505": "HTTP Version Not Supported",\n  "506": "Variant Also Negotiates",\n  "507": "Insufficient Storage",\n  "508": "Loop Detected",\n  "509": "Bandwidth Limit Exceeded",\n  "510": "Not Extended",\n  "511": "Network Authentication Required"\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return (res) => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\n\nfunction set(...args) {\n  return (res) => {\n    const [name, value] = args;\n    if (typeof name === "string") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\n\nvar cookie = (name, value, options) => {\n  return (res) => {\n    const serializedCookie = cookie__WEBPACK_IMPORTED_MODULE_5__.serialize(name, value, options);\n    res.headers.append("Set-Cookie", serializedCookie);\n    if (typeof document !== "undefined") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = (value) => {\n  return (res) => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "application/json");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { data: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = (payload) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { extensions: payload });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n};\nvar delay = (durationOrMode) => {\n  return (res) => {\n    let delayTime;\n    if (typeof durationOrMode === "string") {\n      switch (durationOrMode) {\n        case "infinite": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case "real": {\n          delayTime = getRandomServerResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode "${durationOrMode}". Please make sure you provide one of the supported modes ("real", "infinite") or a number to "ctx.delay".`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === "undefined") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for "setTimeout" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the "infinite" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = (errorsList) => {\n  return (res) => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { errors: errorsList });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\n\n\nvar useFetch = (0,is_node_process__WEBPACK_IMPORTED_MODULE_12__.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(__require("node-fetch"))).then(\n  ({ default: nodeFetch }) => nodeFetch(input, init)\n) : globalThis.fetch;\nvar augmentRequestInit = (requestInit) => {\n  const headers = new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers(requestInit.headers);\n  headers.set("x-msw-bypass", "true");\n  return {\n    ...requestInit,\n    headers: headers.all()\n  };\n};\nvar createFetchRequestParameters = (input) => {\n  const { body: body2, method } = input;\n  const requestParameters = {\n    ...input,\n    body: void 0\n  };\n  if (["GET", "HEAD"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === "object" || typeof body2 === "number" || typeof body2 === "boolean") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = (input, requestInit = {}) => {\n  if (typeof input === "string") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "text/plain");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = (body2) => {\n  return (res) => {\n    res.headers.set("Content-Type", "text/xml");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return "#69AB32" /* Success */;\n  }\n  if (status2 < 400) {\n    return "#F0BB4B" /* Warning */;\n  }\n  return "#E95F5D" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map((chunk) => chunk.slice(0, 2)).map((chunk) => chunk.padStart(2, "0")).join(":");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all()\n  };\n}\n\n// src/utils/logging/prepareResponse.ts\n\nfunction prepareResponse(res) {\n  const responseHeaders = (0,headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.objectToHeaders)(res.headers);\n  const parsedBody = parseBody(res.body, responseHeaders);\n  return {\n    ...res,\n    body: parsedBody\n  };\n}\n\n// src/utils/matching/matchRequestUrl.ts\n\n\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, "http://localhost").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, "");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith("*")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== "undefined" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(\n    /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n    (_, parameterName, wildcard) => {\n      const expression = "(.*)";\n      if (!parameterName) {\n        return expression;\n      }\n      return parameterName.startsWith(":") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n    }\n  ).replace(/([^\\/])(:)(?=\\d+)/, "$1\\\\$2").replace(/^([^\\/]+)(:)(?=\\/\\/)/, "$1\\\\$2");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === "string" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0,_mswjs_interceptors_lib_utils_getCleanUrl_js__WEBPACK_IMPORTED_MODULE_13__.getCleanUrl)(url);\n  const result = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_14__.match)(cleanPath, { decode: decodeURIComponent })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\n\n\n// src/response.ts\n\n\n// src/utils/internal/compose.ts\nfunction compose(...fns) {\n  return (...args) => {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, args[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "NetworkError";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: "OK",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides, defaultTransformers = defaultResponseTransformers) {\n  return async (...transformers) => {\n    const initialResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new headers_polyfill__WEBPACK_IMPORTED_MODULE_8__.Headers({\n          "x-powered-by": "msw"\n        })\n      },\n      responseOverrides\n    );\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers\n    ].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split("\\n").slice(1);\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, "$1").replace(/^@/, "");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == "function";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = {\n      ...options.info,\n      callFrame\n    };\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext\n    );\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext\n    );\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx\n    );\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse\n    );\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || await resolver(req, res, ctx);\n      if (isIterable(result)) {\n        const { value, done } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml\n};\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, {\n      ...request,\n      body: request["_body"]\n    });\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const { method, path } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for "${method} ${path}". Please match against a path instead and access query parameters in the response resolver function using "req.url.searchParams".`\n    );\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext == null ? void 0 : resolutionContext.baseUrl\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(\n      devUtils.formatMessage("%s %s %s (%c%s%c)"),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      "color:inherit"\n    );\n    console.log("Request", loggedRequest);\n    console.log("Handler:", this);\n    console.log("Response", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\n\nvar field = (fieldName, fieldValue) => {\n  return (res) => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName.trim() !== "",\n    devUtils.formatMessage(\n      "Failed to set a custom field on a GraphQL response: field name cannot be empty."\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== "data",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.data()" instead?\',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== "errors",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.errors()" instead?\',\n      fieldName\n    )\n  );\n  (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n    fieldName !== "extensions",\n    devUtils.formatMessage(\n      \'Failed to set a custom "%s" field on a mocked GraphQL response: forbidden field name. Did you mean to call "ctx.extensions()" instead?\',\n      fieldName\n    )\n  );\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n};\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === "object" && "kind" in value && "definitions" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables, operationName) {\n    super(request.url, {\n      ...request,\n      body: request["_body"]\n    });\n    this.variables = variables;\n    this.operationName = operationName;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected "${operationType}", but got "${parsedNode.operationType}").`\n        );\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`\n        );\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === "all" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error2) => console.error(error2.message)\n    );\n  }\n  getPublicRequest(request, parsedResult) {\n    var _a, _b;\n    return new GraphQLRequest(\n      request,\n      (_a = parsedResult == null ? void 0 : parsedResult.variables) != null ? _a : {},\n      (_b = parsedResult == null ? void 0 : parsedResult.operationName) != null ? _b : ""\n    );\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== "all") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at "${request.method} ${publicUrl}": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using "graphql.operation()" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === "all" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || "") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(\n      devUtils.formatMessage("%s %s (%c%s%c)"),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response2.status} ${response2.statusText}`,\n      "color:inherit"\n    );\n    console.log("Request:", loggedRequest);\n    console.log("Handler:", this);\n    console.log("Response:", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler);\n      }\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler);\n      }\n      return groups;\n    },\n    {\n      rest: [],\n      graphql: []\n    }\n  );\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const { path, method } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === "undefined") {\n      return Infinity;\n    }\n    const { operationType, operationName } = handler.info;\n    if (typeof operationName !== "string") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = js_levenshtein__WEBPACK_IMPORTED_MODULE_10__(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  \\u2022 ${handler.info.header}`).join("\\n")}`;\n  }\n  return `Did you mean to request "${handlers[0].info.header}" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = "warn") {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore()\n    );\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : "";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`\n    ].filter(Boolean);\n    return messageTemplate.join("\\n\\n");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case "error": {\n        devUtils.error("Error: %s", message);\n        throw new Error(\n          devUtils.formatMessage(\n            \'Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.\'\n          )\n        );\n      }\n      case "warn": {\n        devUtils.warn("Warning: %s", message);\n        break;\n      }\n      case "bypass":\n        break;\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            \'Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.\',\n            strategy2\n          )\n        );\n    }\n  }\n  if (typeof strategy === "function") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, "warn"),\n      error: applyStrategy.bind(null, "error")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\n\nfunction readResponseCookies(request, response2) {\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.add({ ...request, url: request.url.toString() }, response2);\n  _mswjs_cookies__WEBPACK_IMPORTED_MODULE_6__.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit("request:start", request);\n  if (request.headers.get("x-msw-bypass") === "true") {\n    emitter.emit("request:end", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0,_open_draft_until__WEBPACK_IMPORTED_MODULE_9__.until)(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext\n    );\n  });\n  if (lookupError) {\n    emitter.emit("unhandledException", lookupError, request);\n    throw lookupError;\n  }\n  const { handler, response: response2 } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit("request:unhandled", request);\n    emitter.emit("request:end", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(\n      `Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`,\n      response2,\n      handler.info.header,\n      handler.info.callFrame\n    );\n    emitter.emit("request:end", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit("request:end", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit("request:match", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(\n    handleRequestOptions,\n    transformedResponse,\n    requiredLookupResult\n  );\n  emitter.emit("request:end", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar { bold } = chalk__WEBPACK_IMPORTED_MODULE_1__;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: "warn"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors, ...handlers) {\n    super(...handlers);\n    this.interceptor = new _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.BatchInterceptor({\n      name: "setup-server",\n      interceptors: interceptors.map((Interceptor2) => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on("request", async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer()\n      });\n      const response2 = await handleRequest(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response3) {\n            return {\n              status: response3.status,\n              statusText: response3.statusText,\n              headers: response3.headers.all(),\n              body: response3.body,\n              delay: response3.delay\n            };\n          }\n        }\n      );\n      if (response2) {\n        if (response2.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on("response", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get("x-powered-by") === "msw") {\n        this.emitter.emit("response:mocked", response2, request.id);\n      } else {\n        this.emitter.emit("response:bypass", response2, request.id);\n      }\n    });\n  }\n  listen(options = {}) {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options\n    );\n    this.interceptor.apply();\n    (0,outvariant__WEBPACK_IMPORTED_MODULE_2__.invariant)(\n      [_mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLYING, _mswjs_interceptors__WEBPACK_IMPORTED_MODULE_3__.InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState\n      ),\n      devUtils.formatMessage(\n        \'Failed to start "setupServer": the interceptor failed to apply. This is likely an issue with the library and you should report it at "%s".\'\n      ),\n      "https://github.com/mswjs/msw/issues/new/choose"\n    );\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info;\n      const pragma = handler.info.hasOwnProperty("operationType") ? "[graphql]" : "[rest]";\n      console.log(`${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`);\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\n\n\n\nvar setupServer = (...handlers) => {\n  return new SetupServerApi(\n    [_mswjs_interceptors_lib_interceptors_ClientRequest_index_js__WEBPACK_IMPORTED_MODULE_15__.ClientRequestInterceptor, _mswjs_interceptors_lib_interceptors_XMLHttpRequest_index_js__WEBPACK_IMPORTED_MODULE_16__.XMLHttpRequestInterceptor, _mswjs_interceptors_lib_interceptors_fetch_index_js__WEBPACK_IMPORTED_MODULE_17__.FetchInterceptor],\n    ...handlers\n  );\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXN3L2xpYi9ub2RlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkcseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBOztBQUVBO0FBQ3NEO0FBQ3RELGlCQUFpQiw4Q0FBYzs7QUFFL0I7QUFDMEI7QUFDMkI7QUFJeEI7O0FBRTdCO0FBQ3VDO0FBQ1E7O0FBRS9DO0FBQ29DO0FBQ3BDO0FBQ0E7QUFDQSw4QkFBOEIsa0RBQU07QUFDcEMsWUFBWSxnQkFBZ0IsRUFBRSxvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFPO0FBQzlCLDZCQUE2Qix5REFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixpRUFBZTtBQUNy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O0FBQ0EscUJBQXFCLHFEQUFRO0FBQzdCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLEVBQUUsS0FBSztBQUNsQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFVO0FBQ2QsT0FBTyxzRUFBcUIsV0FBVyxzRUFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EscUJBQXFCLFFBQVEsUUFBUSxFQUFFLE9BQU87QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1RztBQUNFO0FBQ2xCO0FBQ3ZGO0FBQ0E7QUFDQSxLQUFLLGtIQUF3QixFQUFFLG9IQUF5QixFQUFFLGtHQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXJlYWN0LWNoYWtyYXVpLy4vbm9kZV9tb2R1bGVzL21zdy9saWIvbm9kZS9pbmRleC5tanM/YTRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcmVxdWlyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHgpID0+IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBQcm94eSh4LCB7XG4gIGdldDogKGEsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiBhKVtiXVxufSkgOiB4KShmdW5jdGlvbih4KSB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicgKyB4ICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn0pO1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIGNvbmZpZy9wb2x5ZmlsbHMtbm9kZS50c1xuaW1wb3J0IHsgc2V0VGltZW91dCBhcyBub2RlU2V0VGltZW91dCB9IGZyb20gXCJ0aW1lcnNcIjtcbnZhciBzZXRUaW1lb3V0ID0gbm9kZVNldFRpbWVvdXQ7XG5cbi8vIHNyYy9ub2RlL1NldHVwU2VydmVyQXBpLnRzXG5pbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgeyBpbnZhcmlhbnQgYXMgaW52YXJpYW50MyB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG5pbXBvcnQge1xuICBCYXRjaEludGVyY2VwdG9yLFxuICBJbnRlcmNlcHRvclJlYWR5U3RhdGVcbn0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnNcIjtcblxuLy8gc3JjL1NldHVwQXBpLnRzXG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tIFwib3V0dmFyaWFudFwiO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJzdHJpY3QtZXZlbnQtZW1pdHRlclwiO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvZGV2VXRpbHMudHNcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gXCJvdXR2YXJpYW50XCI7XG52YXIgTElCUkFSWV9QUkVGSVggPSBcIltNU1ddXCI7XG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSB7XG4gIGNvbnN0IGludGVycG9sYXRlZE1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpO1xuICByZXR1cm4gYCR7TElCUkFSWV9QUkVGSVh9ICR7aW50ZXJwb2xhdGVkTWVzc2FnZX1gO1xufVxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykge1xuICBjb25zb2xlLndhcm4oZm9ybWF0TWVzc2FnZShtZXNzYWdlLCAuLi5wb3NpdGlvbmFscykpO1xufVxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgLi4ucG9zaXRpb25hbHMpIHtcbiAgY29uc29sZS5lcnJvcihmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIC4uLnBvc2l0aW9uYWxzKSk7XG59XG52YXIgZGV2VXRpbHMgPSB7XG4gIGZvcm1hdE1lc3NhZ2UsXG4gIHdhcm4sXG4gIGVycm9yXG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGlwZUV2ZW50cy50c1xuZnVuY3Rpb24gcGlwZUV2ZW50cyhzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHJhd0VtaXQgPSBzb3VyY2UuZW1pdDtcbiAgaWYgKHJhd0VtaXQuX2lzUGlwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc291cmNlLmVtaXQgPSBmdW5jdGlvbihldmVudCwgLi4uZGF0YTIpIHtcbiAgICBkZXN0aW5hdGlvbi5lbWl0KGV2ZW50LCAuLi5kYXRhMik7XG4gICAgcmV0dXJuIHJhd0VtaXQuY2FsbCh0aGlzLCBldmVudCwgLi4uZGF0YTIpO1xuICB9O1xuICBzb3VyY2UuZW1pdC5faXNQaXBlZCA9IHRydWU7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC90b1JlYWRvbmx5QXJyYXkudHNcbmZ1bmN0aW9uIHRvUmVhZG9ubHlBcnJheShzb3VyY2UpIHtcbiAgY29uc3QgY2xvbmUgPSBbLi4uc291cmNlXTtcbiAgT2JqZWN0LmZyZWV6ZShjbG9uZSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuLy8gc3JjL1NldHVwQXBpLnRzXG52YXIgU2V0dXBBcGkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmluaXRpYWxIYW5kbGVycykge1xuICAgIHRoaXMudmFsaWRhdGVIYW5kbGVycyguLi5pbml0aWFsSGFuZGxlcnMpO1xuICAgIHRoaXMuaW5pdGlhbEhhbmRsZXJzID0gdG9SZWFkb25seUFycmF5KGluaXRpYWxIYW5kbGVycyk7XG4gICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBbLi4uaW5pdGlhbEhhbmRsZXJzXTtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIHRoaXMucHVibGljRW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgcGlwZUV2ZW50cyh0aGlzLmVtaXR0ZXIsIHRoaXMucHVibGljRW1pdHRlcik7XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLmNyZWF0ZUxpZmVDeWNsZUV2ZW50cygpO1xuICB9XG4gIHZhbGlkYXRlSGFuZGxlcnMoLi4uaGFuZGxlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoaGFuZGxlciksXG4gICAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXCIlc1wiIGdpdmVuIGFuIEFycmF5IG9mIHJlcXVlc3QgaGFuZGxlcnMuIE1ha2Ugc3VyZSB5b3Ugc3ByZWFkIHRoZSByZXF1ZXN0IGhhbmRsZXJzIHdoZW4gY2FsbGluZyB0aGUgcmVzcGVjdGl2ZSBzZXR1cCBmdW5jdGlvbi4nXG4gICAgICAgICksXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IubmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIHVzZSguLi5ydW50aW1lSGFuZGxlcnMpIHtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycy51bnNoaWZ0KC4uLnJ1bnRpbWVIYW5kbGVycyk7XG4gIH1cbiAgcmVzdG9yZUhhbmRsZXJzKCkge1xuICAgIHRoaXMuY3VycmVudEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgIGhhbmRsZXIubWFya0FzU2tpcHBlZChmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRIYW5kbGVycyguLi5uZXh0SGFuZGxlcnMpIHtcbiAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyA9IG5leHRIYW5kbGVycy5sZW5ndGggPiAwID8gWy4uLm5leHRIYW5kbGVyc10gOiBbLi4udGhpcy5pbml0aWFsSGFuZGxlcnNdO1xuICB9XG4gIGxpc3RIYW5kbGVycygpIHtcbiAgICByZXR1cm4gdG9SZWFkb25seUFycmF5KHRoaXMuY3VycmVudEhhbmRsZXJzKTtcbiAgfVxuICBjcmVhdGVMaWZlQ3ljbGVFdmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLm9uKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbExpc3RlbmVyczogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljRW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoLi4uYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzT2JqZWN0LnRzXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvbWVyZ2VSaWdodC50c1xuZnVuY3Rpb24gbWVyZ2VSaWdodChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmlnaHQpLnJlZHVjZSgocmVzdWx0LCBba2V5LCByaWdodFZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHJlc3VsdFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnRWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShyaWdodFZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsZWZ0VmFsdWUuY29uY2F0KHJpZ2h0VmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGxlZnRWYWx1ZSkgJiYgaXNPYmplY3QocmlnaHRWYWx1ZSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VSaWdodChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0W2tleV0gPSByaWdodFZhbHVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIE9iamVjdC5hc3NpZ24oe30sIGxlZnQpKTtcbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvTW9ja2VkUmVxdWVzdC50c1xuaW1wb3J0ICogYXMgY29va2llVXRpbHMyIGZyb20gXCJjb29raWVcIjtcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSBcIkBtc3dqcy9jb29raWVzXCI7XG5pbXBvcnQgeyBJc29tb3JwaGljUmVxdWVzdCB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzXCI7XG5pbXBvcnQgeyBkZWNvZGVCdWZmZXIgfSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvdXRpbHMvYnVmZmVyVXRpbHMuanNcIjtcbmltcG9ydCB7IEhlYWRlcnMgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9nZXRSZXF1ZXN0Q29va2llcy50c1xuaW1wb3J0ICogYXMgY29va2llVXRpbHMgZnJvbSBcImNvb2tpZVwiO1xuZnVuY3Rpb24gZ2V0QWxsQ29va2llcygpIHtcbiAgcmV0dXJuIGNvb2tpZVV0aWxzLnBhcnNlKGRvY3VtZW50LmNvb2tpZSk7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0Q29va2llcyhyZXF1ZXN0KSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGxvY2F0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN3aXRjaCAocmVxdWVzdC5jcmVkZW50aWFscykge1xuICAgIGNhc2UgXCJzYW1lLW9yaWdpblwiOiB7XG4gICAgICByZXR1cm4gbG9jYXRpb24ub3JpZ2luID09PSByZXF1ZXN0LnVybC5vcmlnaW4gPyBnZXRBbGxDb29raWVzKCkgOiB7fTtcbiAgICB9XG4gICAgY2FzZSBcImluY2x1ZGVcIjoge1xuICAgICAgcmV0dXJuIGdldEFsbENvb2tpZXMoKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvanNvblBhcnNlLnRzXG5mdW5jdGlvbiBqc29uUGFyc2UodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BhcnNlTXVsdGlwYXJ0RGF0YS50c1xuaW1wb3J0IHsgc3RyaW5nVG9IZWFkZXJzIH0gZnJvbSBcImhlYWRlcnMtcG9seWZpbGxcIjtcbmZ1bmN0aW9uIHBhcnNlQ29udGVudEhlYWRlcnMoaGVhZGVyc1N0cmluZykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBoZWFkZXJzID0gc3RyaW5nVG9IZWFkZXJzKGhlYWRlcnNTdHJpbmcpO1xuICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwidGV4dC9wbGFpblwiO1xuICBjb25zdCBkaXNwb3NpdGlvbiA9IGhlYWRlcnMuZ2V0KFwiY29udGVudC1kaXNwb3NpdGlvblwiKTtcbiAgaWYgKCFkaXNwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJDb250ZW50LURpc3Bvc2l0aW9uXCIgaGVhZGVyIGlzIHJlcXVpcmVkLicpO1xuICB9XG4gIGNvbnN0IGRpcmVjdGl2ZXMgPSBkaXNwb3NpdGlvbi5zcGxpdChcIjtcIikucmVkdWNlKChhY2MsIGNodW5rKSA9PiB7XG4gICAgY29uc3QgW25hbWUyLCAuLi5yZXN0XSA9IGNodW5rLnRyaW0oKS5zcGxpdChcIj1cIik7XG4gICAgYWNjW25hbWUyXSA9IHJlc3Quam9pbihcIj1cIik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBjb25zdCBuYW1lID0gKF9hID0gZGlyZWN0aXZlcy5uYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2xpY2UoMSwgLTEpO1xuICBjb25zdCBmaWxlbmFtZSA9IChfYiA9IGRpcmVjdGl2ZXMuZmlsZW5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zbGljZSgxLCAtMSk7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBmaWxlbmFtZSxcbiAgICBjb250ZW50VHlwZVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VNdWx0aXBhcnREYXRhKGRhdGEyLCBoZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycyA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gIGlmICghY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFssIC4uLmRpcmVjdGl2ZXNdID0gY29udGVudFR5cGUuc3BsaXQoLzsgKi8pO1xuICBjb25zdCBib3VuZGFyeSA9IGRpcmVjdGl2ZXMuZmlsdGVyKChkKSA9PiBkLnN0YXJ0c1dpdGgoXCJib3VuZGFyeT1cIikpLm1hcCgocykgPT4gcy5yZXBsYWNlKC9eYm91bmRhcnk9LywgXCJcIikpWzBdO1xuICBpZiAoIWJvdW5kYXJ5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBib3VuZGFyeVJlZ0V4cCA9IG5ldyBSZWdFeHAoYC0tKyR7Ym91bmRhcnl9YCk7XG4gIGNvbnN0IGZpZWxkcyA9IGRhdGEyLnNwbGl0KGJvdW5kYXJ5UmVnRXhwKS5maWx0ZXIoKGNodW5rKSA9PiBjaHVuay5zdGFydHNXaXRoKFwiXFxyXFxuXCIpICYmIGNodW5rLmVuZHNXaXRoKFwiXFxyXFxuXCIpKS5tYXAoKGNodW5rKSA9PiBjaHVuay50cmltU3RhcnQoKS5yZXBsYWNlKC9cXHJcXG4kLywgXCJcIikpO1xuICBpZiAoIWZpZWxkcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHBhcnNlZEJvZHkgPSB7fTtcbiAgdHJ5IHtcbiAgICBmb3IgKGNvbnN0IGZpZWxkMiBvZiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IFtjb250ZW50SGVhZGVycywgLi4ucmVzdF0gPSBmaWVsZDIuc3BsaXQoXCJcXHJcXG5cXHJcXG5cIik7XG4gICAgICBjb25zdCBjb250ZW50Qm9keSA9IHJlc3Quam9pbihcIlxcclxcblxcclxcblwiKTtcbiAgICAgIGNvbnN0IHsgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlMiwgZmlsZW5hbWUsIG5hbWUgfSA9IHBhcnNlQ29udGVudEhlYWRlcnMoY29udGVudEhlYWRlcnMpO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaWxlbmFtZSA9PT0gdm9pZCAwID8gY29udGVudEJvZHkgOiBuZXcgRmlsZShbY29udGVudEJvZHldLCBmaWxlbmFtZSwgeyB0eXBlOiBjb250ZW50VHlwZTIgfSk7XG4gICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZEJvZHlbbmFtZV07XG4gICAgICBpZiAocGFyc2VkVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZWRCb2R5W25hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSBbLi4ucGFyc2VkVmFsdWUsIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZEJvZHlbbmFtZV0gPSBbcGFyc2VkVmFsdWUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcGFyc2VCb2R5LnRzXG5mdW5jdGlvbiBwYXJzZUJvZHkoYm9keTIsIGhlYWRlcnMpIHtcbiAgdmFyIF9hO1xuICBpZiAoIWJvZHkyKSB7XG4gICAgcmV0dXJuIGJvZHkyO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gKChfYSA9IGhlYWRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgfHwgXCJcIjtcbiAgY29uc3QgaGFzTXVsdGlwYXJ0Q29udGVudCA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpO1xuICBpZiAoaGFzTXVsdGlwYXJ0Q29udGVudCAmJiB0eXBlb2YgYm9keTIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gcGFyc2VNdWx0aXBhcnREYXRhKGJvZHkyLnRvU3RyaW5nKCksIGhlYWRlcnMpIHx8IGJvZHkyO1xuICB9XG4gIGNvbnN0IGhhc0pzb25Db250ZW50ID0gY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpO1xuICBpZiAoaGFzSnNvbkNvbnRlbnQgJiYgdHlwZW9mIGJvZHkyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGpzb25QYXJzZShib2R5Mi50b1N0cmluZygpKSB8fCBib2R5MjtcbiAgfVxuICByZXR1cm4gYm9keTI7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9pc1N0cmluZ0VxdWFsLnRzXG5mdW5jdGlvbiBpc1N0cmluZ0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgcmV0dXJuIGFjdHVhbC50b0xvd2VyQ2FzZSgpID09PSBleHBlY3RlZC50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVxdWVzdC9Nb2NrZWRSZXF1ZXN0LnRzXG52YXIgTW9ja2VkUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgSXNvbW9ycGhpY1JlcXVlc3Qge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGluaXQgPSB7fSkge1xuICAgIHN1cGVyKHVybCwgaW5pdCk7XG4gICAgaWYgKGluaXQuaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpbml0LmlkO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlID0gaW5pdC5jYWNoZSB8fCBcImRlZmF1bHRcIjtcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gaW5pdC5kZXN0aW5hdGlvbiB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZWdyaXR5ID0gaW5pdC5pbnRlZ3JpdHkgfHwgXCJcIjtcbiAgICB0aGlzLmtlZXBhbGl2ZSA9IGluaXQua2VlcGFsaXZlIHx8IGZhbHNlO1xuICAgIHRoaXMubW9kZSA9IGluaXQubW9kZSB8fCBcImNvcnNcIjtcbiAgICB0aGlzLnByaW9yaXR5ID0gaW5pdC5wcmlvcml0eSB8fCBcImF1dG9cIjtcbiAgICB0aGlzLnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdCB8fCBcImZvbGxvd1wiO1xuICAgIHRoaXMucmVmZXJyZXIgPSBpbml0LnJlZmVycmVyIHx8IFwiXCI7XG4gICAgdGhpcy5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3kgfHwgXCJuby1yZWZlcnJlclwiO1xuICAgIHRoaXMuY29va2llcyA9IGluaXQuY29va2llcyB8fCB0aGlzLmdldENvb2tpZXMoKTtcbiAgfVxuICBnZXQgYm9keSgpIHtcbiAgICBjb25zdCB0ZXh0MiA9IGRlY29kZUJ1ZmZlcih0aGlzW1wiX2JvZHlcIl0pO1xuICAgIGNvbnN0IGJvZHkyID0gcGFyc2VCb2R5KHRleHQyLCB0aGlzLmhlYWRlcnMpO1xuICAgIGlmIChpc1N0cmluZ0VxdWFsKHRoaXMubWV0aG9kLCBcIkdFVFwiKSAmJiBib2R5MiA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHkyO1xuICB9XG4gIHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IDEwMSxcbiAgICAgIHN0YXR1c1RleHQ6IFwiQ29udGludWVcIixcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgICBib2R5OiBudWxsLFxuICAgICAgcGFzc3Rocm91Z2g6IHRydWUsXG4gICAgICBvbmNlOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgZ2V0Q29va2llcygpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVxdWVzdENvb2tpZXNTdHJpbmcgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpO1xuICAgIGNvbnN0IG93bkNvb2tpZXMgPSByZXF1ZXN0Q29va2llc1N0cmluZyA/IGNvb2tpZVV0aWxzMi5wYXJzZShyZXF1ZXN0Q29va2llc1N0cmluZykgOiB7fTtcbiAgICBzdG9yZS5oeWRyYXRlKCk7XG4gICAgY29uc3QgY29va2llc0Zyb21TdG9yZSA9IEFycmF5LmZyb20oXG4gICAgICAoX2EgPSBzdG9yZS5nZXQoeyAuLi50aGlzLCB1cmw6IHRoaXMudXJsLmhyZWYgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbnRyaWVzKClcbiAgICApLnJlZHVjZSgoY29va2llcywgW25hbWUsIHsgdmFsdWUgfV0pID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNvb2tpZXMsIHsgW25hbWUudHJpbSgpXTogdmFsdWUgfSk7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGNvb2tpZXNGcm9tRG9jdW1lbnQgPSBnZXRSZXF1ZXN0Q29va2llcyh0aGlzKTtcbiAgICBjb25zdCBmb3J3YXJkZWRDb29raWVzID0ge1xuICAgICAgLi4uY29va2llc0Zyb21Eb2N1bWVudCxcbiAgICAgIC4uLmNvb2tpZXNGcm9tU3RvcmVcbiAgICB9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3J3YXJkZWRDb29raWVzKSkge1xuICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZChcImNvb2tpZVwiLCBgJHtuYW1lfT0ke3ZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9yd2FyZGVkQ29va2llcyxcbiAgICAgIC4uLm93bkNvb2tpZXNcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaGFuZGxlUmVxdWVzdC50c1xuaW1wb3J0IHsgdW50aWwgfSBmcm9tIFwiQG9wZW4tZHJhZnQvdW50aWxcIjtcblxuLy8gc3JjL3V0aWxzL2dldFJlc3BvbnNlLnRzXG52YXIgZ2V0UmVzcG9uc2UgPSBhc3luYyAocmVxdWVzdCwgaGFuZGxlcnMsIHJlc29sdXRpb25Db250ZXh0KSA9PiB7XG4gIGNvbnN0IHJlbGV2YW50SGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoKGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gaGFuZGxlci50ZXN0KHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgfSk7XG4gIGlmIChyZWxldmFudEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB2b2lkIDAsXG4gICAgICByZXNwb25zZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWxldmFudEhhbmRsZXJzLnJlZHVjZShhc3luYyAoZXhlY3V0aW9uUmVzdWx0LCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNSZXN1bHRzID0gYXdhaXQgZXhlY3V0aW9uUmVzdWx0O1xuICAgIGlmICghIShwcmV2aW91c1Jlc3VsdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzUmVzdWx0cy5yZXNwb25zZSkpIHtcbiAgICAgIHJldHVybiBleGVjdXRpb25SZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBoYW5kbGVyLnJ1bihyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCk7XG4gICAgaWYgKHJlc3VsdDIgPT09IG51bGwgfHwgcmVzdWx0Mi5oYW5kbGVyLnNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdDIucmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IHJlc3VsdDIucmVxdWVzdCxcbiAgICAgICAgaGFuZGxlcjogcmVzdWx0Mi5oYW5kbGVyLFxuICAgICAgICByZXNwb25zZTogdm9pZCAwLFxuICAgICAgICBwYXJzZWRSZXN1bHQ6IHJlc3VsdDIucGFyc2VkUmVzdWx0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0Mi5yZXNwb25zZS5vbmNlKSB7XG4gICAgICBoYW5kbGVyLm1hcmtBc1NraXBwZWQodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyOiB2b2lkIDAsXG4gICAgICByZXNwb25zZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IHJlc3VsdC5oYW5kbGVyLFxuICAgIHB1YmxpY1JlcXVlc3Q6IHJlc3VsdC5yZXF1ZXN0LFxuICAgIHBhcnNlZFJlcXVlc3Q6IHJlc3VsdC5wYXJzZWRSZXN1bHQsXG4gICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICB9O1xufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3Qvb25VbmhhbmRsZWRSZXF1ZXN0LnRzXG5pbXBvcnQgZ2V0U3RyaW5nTWF0Y2hTY29yZSBmcm9tIFwianMtbGV2ZW5zaHRlaW5cIjtcblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL3BhcnNlR3JhcGhRTFJlcXVlc3QudHNcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlMyB9IGZyb20gXCJncmFwaHFsXCI7XG5cbi8vIHNyYy91dGlscy9yZXF1ZXN0L2dldFB1YmxpY1VybEZyb21SZXF1ZXN0LnRzXG52YXIgZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QgPSAocmVxdWVzdCkgPT4ge1xuICByZXR1cm4gcmVxdWVzdC5yZWZlcnJlci5zdGFydHNXaXRoKHJlcXVlc3QudXJsLm9yaWdpbikgPyByZXF1ZXN0LnVybC5wYXRobmFtZSA6IG5ldyBVUkwoXG4gICAgcmVxdWVzdC51cmwucGF0aG5hbWUsXG4gICAgYCR7cmVxdWVzdC51cmwucHJvdG9jb2x9Ly8ke3JlcXVlc3QudXJsLmhvc3R9YFxuICApLmhyZWY7XG59O1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvcGFyc2VHcmFwaFFMUmVxdWVzdC50c1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudE5vZGUobm9kZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG9wZXJhdGlvbkRlZiA9IG5vZGUuZGVmaW5pdGlvbnMuZmluZCgoZGVmKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIjtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uVHlwZTogb3BlcmF0aW9uRGVmID09IG51bGwgPyB2b2lkIDAgOiBvcGVyYXRpb25EZWYub3BlcmF0aW9uLFxuICAgIG9wZXJhdGlvbk5hbWU6IChfYSA9IG9wZXJhdGlvbkRlZiA9PSBudWxsID8gdm9pZCAwIDogb3BlcmF0aW9uRGVmLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VRdWVyeShxdWVyeSkge1xuICB0cnkge1xuICAgIGNvbnN0IGFzdCA9IHBhcnNlMyhxdWVyeSk7XG4gICAgcmV0dXJuIHBhcnNlRG9jdW1lbnROb2RlKGFzdCk7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICAgIHJldHVybiBlcnJvcjI7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXModmFyaWFibGVzLCBtYXAsIGZpbGVzKSB7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSB7IHZhcmlhYmxlcyB9O1xuICBmb3IgKGNvbnN0IFtrZXksIHBhdGhBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgIGlmICghKGtleSBpbiBmaWxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2l2ZW4gZmlsZXMgZG8gbm90IGhhdmUgYSBrZXkgJyR7a2V5fScgLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvdFBhdGggb2YgcGF0aEFycmF5KSB7XG4gICAgICBjb25zdCBbbGFzdFBhdGgsIC4uLnJldmVyc2VkUGF0aHNdID0gZG90UGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgY29uc3QgcGF0aHMgPSByZXZlcnNlZFBhdGhzLnJldmVyc2UoKTtcbiAgICAgIGxldCB0YXJnZXQgPSBvcGVyYXRpb25zO1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmICghKHBhdGggaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7cGF0aHN9JyBpcyBub3QgaW4gb3BlcmF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXRbcGF0aF07XG4gICAgICB9XG4gICAgICB0YXJnZXRbbGFzdFBhdGhdID0gZmlsZXNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbnMudmFyaWFibGVzO1xufVxuZnVuY3Rpb24gZ2V0R3JhcGhRTElucHV0KHJlcXVlc3QpIHtcbiAgdmFyIF9hLCBfYjtcbiAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgIGNhc2UgXCJHRVRcIjoge1xuICAgICAgY29uc3QgcXVlcnkgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicXVlcnlcIik7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSByZXF1ZXN0LnVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmFyaWFibGVzXCIpIHx8IFwiXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgdmFyaWFibGVzOiBqc29uUGFyc2UodmFyaWFibGVzKVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIlBPU1RcIjoge1xuICAgICAgaWYgKChfYSA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgcXVlcnksIHZhcmlhYmxlcyB9ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHZhcmlhYmxlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHJlcXVlc3QuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBvcGVyYXRpb25zLCBtYXAsIC4uLmZpbGVzIH0gPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIGNvbnN0IHBhcnNlZE9wZXJhdGlvbnMgPSBqc29uUGFyc2UoXG4gICAgICAgICAgb3BlcmF0aW9uc1xuICAgICAgICApIHx8IHt9O1xuICAgICAgICBpZiAoIXBhcnNlZE9wZXJhdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRNYXAgPSBqc29uUGFyc2UobWFwIHx8IFwiXCIpIHx8IHt9O1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBwYXJzZWRPcGVyYXRpb25zLnZhcmlhYmxlcyA/IGV4dHJhY3RNdWx0aXBhcnRWYXJpYWJsZXMoXG4gICAgICAgICAgcGFyc2VkT3BlcmF0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgcGFyc2VkTWFwLFxuICAgICAgICAgIGZpbGVzXG4gICAgICAgICkgOiB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBxdWVyeTogcGFyc2VkT3BlcmF0aW9ucy5xdWVyeSxcbiAgICAgICAgICB2YXJpYWJsZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgY29uc3QgaW5wdXQgPSBnZXRHcmFwaFFMSW5wdXQocmVxdWVzdCk7XG4gIGlmICghaW5wdXQgfHwgIWlucHV0LnF1ZXJ5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCB7IHF1ZXJ5LCB2YXJpYWJsZXMgfSA9IGlucHV0O1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBwYXJzZVF1ZXJ5KHF1ZXJ5KTtcbiAgaWYgKHBhcnNlZFJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3QgcmVxdWVzdFB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdGYWlsZWQgdG8gaW50ZXJjZXB0IGEgR3JhcGhRTCByZXF1ZXN0IHRvIFwiJXMgJXNcIjogY2Fubm90IHBhcnNlIHF1ZXJ5LiBTZWUgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgcGFyc2VyIGJlbG93LlxcblxcbiVzJyxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIHJlcXVlc3RQdWJsaWNVcmwsXG4gICAgICAgIHBhcnNlZFJlc3VsdC5tZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvblR5cGU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25UeXBlLFxuICAgIG9wZXJhdGlvbk5hbWU6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lLFxuICAgIHZhcmlhYmxlc1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vc3RhdHVzZXNAMi4wLjEvbm9kZV9tb2R1bGVzL3N0YXR1c2VzL2NvZGVzLmpzb25cbnZhciBjb2Rlc19kZWZhdWx0ID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIxMDNcIjogXCJFYXJseSBIaW50c1wiLFxuICBcIjIwMFwiOiBcIk9LXCIsXG4gIFwiMjAxXCI6IFwiQ3JlYXRlZFwiLFxuICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gIFwiMjAzXCI6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgXCIyMDRcIjogXCJObyBDb250ZW50XCIsXG4gIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICBcIjIwNlwiOiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICBcIjIwN1wiOiBcIk11bHRpLVN0YXR1c1wiLFxuICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgXCIyMjZcIjogXCJJTSBVc2VkXCIsXG4gIFwiMzAwXCI6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gIFwiMzAyXCI6IFwiRm91bmRcIixcbiAgXCIzMDNcIjogXCJTZWUgT3RoZXJcIixcbiAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgXCIzMDVcIjogXCJVc2UgUHJveHlcIixcbiAgXCIzMDdcIjogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgXCI0MDBcIjogXCJCYWQgUmVxdWVzdFwiLFxuICBcIjQwMVwiOiBcIlVuYXV0aG9yaXplZFwiLFxuICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgXCI0MDNcIjogXCJGb3JiaWRkZW5cIixcbiAgXCI0MDRcIjogXCJOb3QgRm91bmRcIixcbiAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgXCI0MDZcIjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICBcIjQwN1wiOiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgXCI0MTBcIjogXCJHb25lXCIsXG4gIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICBcIjQxM1wiOiBcIlBheWxvYWQgVG9vIExhcmdlXCIsXG4gIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gIFwiNDE1XCI6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICBcIjQxNlwiOiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiLFxuICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICBcIjQxOFwiOiBcIkknbSBhIFRlYXBvdFwiLFxuICBcIjQyMVwiOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICBcIjQyM1wiOiBcIkxvY2tlZFwiLFxuICBcIjQyNFwiOiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gIFwiNDI1XCI6IFwiVG9vIEVhcmx5XCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufTtcblxuLy8gc3JjL2NvbnRleHQvc3RhdHVzLnRzXG52YXIgc3RhdHVzID0gKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuc3RhdHVzID0gc3RhdHVzQ29kZTtcbiAgICByZXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgY29kZXNfZGVmYXVsdFtTdHJpbmcoc3RhdHVzQ29kZSldO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9zZXQudHNcbmltcG9ydCB7IG9iamVjdFRvSGVhZGVycyB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5mdW5jdGlvbiBzZXQoLi4uYXJncykge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzLmhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG9iamVjdFRvSGVhZGVycyhuYW1lKTtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUyLCBuYW1lMikgPT4ge1xuICAgICAgICByZXMuaGVhZGVycy5hcHBlbmQobmFtZTIsIHZhbHVlMik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLy8gc3JjL2NvbnRleHQvY29va2llLnRzXG5pbXBvcnQgKiBhcyBjb29raWVVdGlsczMgZnJvbSBcImNvb2tpZVwiO1xudmFyIGNvb2tpZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDb29raWUgPSBjb29raWVVdGlsczMuc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXMuaGVhZGVycy5hcHBlbmQoXCJTZXQtQ29va2llXCIsIHNlcmlhbGl6ZWRDb29raWUpO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRvY3VtZW50LmNvb2tpZSA9IHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9ib2R5LnRzXG52YXIgYm9keSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5ib2R5ID0gdmFsdWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2pzb24udHNcbnZhciBqc29uID0gKGJvZHkyKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgcmVzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICByZXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkyKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLy8gc3JjL2NvbnRleHQvZGF0YS50c1xudmFyIGRhdGEgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIGNvbnN0IHByZXZCb2R5ID0ganNvblBhcnNlKHJlcy5ib2R5KSB8fCB7fTtcbiAgICBjb25zdCBuZXh0Qm9keSA9IG1lcmdlUmlnaHQocHJldkJvZHksIHsgZGF0YTogcGF5bG9hZCB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2V4dGVuc2lvbnMudHNcbnZhciBleHRlbnNpb25zID0gKHBheWxvYWQpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICBjb25zdCBwcmV2Qm9keSA9IGpzb25QYXJzZShyZXMuYm9keSkgfHwge307XG4gICAgY29uc3QgbmV4dEJvZHkgPSBtZXJnZVJpZ2h0KHByZXZCb2R5LCB7IGV4dGVuc2lvbnM6IHBheWxvYWQgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9kZWxheS50c1xuaW1wb3J0IHsgaXNOb2RlUHJvY2VzcyB9IGZyb20gXCJpcy1ub2RlLXByb2Nlc3NcIjtcbnZhciBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQgPSAyMTQ3NDgzNjQ3O1xudmFyIE1JTl9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDEwMDtcbnZhciBNQVhfU0VSVkVSX1JFU1BPTlNFX1RJTUUgPSA0MDA7XG52YXIgTk9ERV9TRVJWRVJfUkVTUE9OU0VfVElNRSA9IDU7XG52YXIgZ2V0UmFuZG9tU2VydmVyUmVzcG9uc2VUaW1lID0gKCkgPT4ge1xuICBpZiAoaXNOb2RlUHJvY2VzcygpKSB7XG4gICAgcmV0dXJuIE5PREVfU0VSVkVSX1JFU1BPTlNFX1RJTUU7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgTWF0aC5yYW5kb20oKSAqIChNQVhfU0VSVkVSX1JFU1BPTlNFX1RJTUUgLSBNSU5fU0VSVkVSX1JFU1BPTlNFX1RJTUUpICsgTUlOX1NFUlZFUl9SRVNQT05TRV9USU1FXG4gICk7XG59O1xudmFyIGRlbGF5ID0gKGR1cmF0aW9uT3JNb2RlKSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgbGV0IGRlbGF5VGltZTtcbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uT3JNb2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzd2l0Y2ggKGR1cmF0aW9uT3JNb2RlKSB7XG4gICAgICAgIGNhc2UgXCJpbmZpbml0ZVwiOiB7XG4gICAgICAgICAgZGVsYXlUaW1lID0gU0VUX1RJTUVPVVRfTUFYX0FMTE9XRURfSU5UO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZWFsXCI6IHtcbiAgICAgICAgICBkZWxheVRpbWUgPSBnZXRSYW5kb21TZXJ2ZXJSZXNwb25zZVRpbWUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBkZWxheSBhIHJlc3BvbnNlOiB1bmtub3duIGRlbGF5IG1vZGUgXCIke2R1cmF0aW9uT3JNb2RlfVwiLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBwcm92aWRlIG9uZSBvZiB0aGUgc3VwcG9ydGVkIG1vZGVzIChcInJlYWxcIiwgXCJpbmZpbml0ZVwiKSBvciBhIG51bWJlciB0byBcImN0eC5kZWxheVwiLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25Pck1vZGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRlbGF5VGltZSA9IGdldFJhbmRvbVNlcnZlclJlc3BvbnNlVGltZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHVyYXRpb25Pck1vZGUgPiBTRVRfVElNRU9VVF9NQVhfQUxMT1dFRF9JTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gZGVsYXkgYSByZXNwb25zZTogcHJvdmlkZWQgZGVsYXkgZHVyYXRpb24gKCR7ZHVyYXRpb25Pck1vZGV9KSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgZHVyYXRpb24gZm9yIFwic2V0VGltZW91dFwiICgke1NFVF9USU1FT1VUX01BWF9BTExPV0VEX0lOVH0pLiBUaGlzIHdpbGwgY2F1c2UgdGhlIHJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5LiBQbGVhc2UgdXNlIGEgbnVtYmVyIHdpdGhpbiB0aGUgYWxsb3dlZCByYW5nZSB0byBkZWxheSB0aGUgcmVzcG9uc2UgYnkgZXhhY3QgZHVyYXRpb24sIG9yIGNvbnNpZGVyIHRoZSBcImluZmluaXRlXCIgZGVsYXkgbW9kZSB0byBkZWxheSB0aGUgcmVzcG9uc2UgaW5kZWZpbml0ZWx5LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlbGF5VGltZSA9IGR1cmF0aW9uT3JNb2RlO1xuICAgIH1cbiAgICByZXMuZGVsYXkgPSBkZWxheVRpbWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L2Vycm9ycy50c1xudmFyIGVycm9ycyA9IChlcnJvcnNMaXN0KSA9PiB7XG4gIHJldHVybiAocmVzKSA9PiB7XG4gICAgaWYgKGVycm9yc0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBlcnJvcnM6IGVycm9yc0xpc3QgfSk7XG4gICAgcmV0dXJuIGpzb24obmV4dEJvZHkpKHJlcyk7XG4gIH07XG59O1xuXG4vLyBzcmMvY29udGV4dC9mZXRjaC50c1xuaW1wb3J0IHsgaXNOb2RlUHJvY2VzcyBhcyBpc05vZGVQcm9jZXNzMiB9IGZyb20gXCJpcy1ub2RlLXByb2Nlc3NcIjtcbmltcG9ydCB7IEhlYWRlcnMgYXMgSGVhZGVyczIgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xudmFyIHVzZUZldGNoID0gaXNOb2RlUHJvY2VzczIoKSA/IChpbnB1dCwgaW5pdCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBfX3RvRVNNKF9fcmVxdWlyZShcIm5vZGUtZmV0Y2hcIikpKS50aGVuKFxuICAoeyBkZWZhdWx0OiBub2RlRmV0Y2ggfSkgPT4gbm9kZUZldGNoKGlucHV0LCBpbml0KVxuKSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgYXVnbWVudFJlcXVlc3RJbml0ID0gKHJlcXVlc3RJbml0KSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVyczIocmVxdWVzdEluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwieC1tc3ctYnlwYXNzXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXF1ZXN0SW5pdCxcbiAgICBoZWFkZXJzOiBoZWFkZXJzLmFsbCgpXG4gIH07XG59O1xudmFyIGNyZWF0ZUZldGNoUmVxdWVzdFBhcmFtZXRlcnMgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgeyBib2R5OiBib2R5MiwgbWV0aG9kIH0gPSBpbnB1dDtcbiAgY29uc3QgcmVxdWVzdFBhcmFtZXRlcnMgPSB7XG4gICAgLi4uaW5wdXQsXG4gICAgYm9keTogdm9pZCAwXG4gIH07XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdFBhcmFtZXRlcnM7XG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5MiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYm9keTIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGJvZHkyID09PSBcImJvb2xlYW5cIikge1xuICAgIHJlcXVlc3RQYXJhbWV0ZXJzLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5Mik7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdFBhcmFtZXRlcnMuYm9keSA9IGJvZHkyO1xuICB9XG4gIHJldHVybiByZXF1ZXN0UGFyYW1ldGVycztcbn07XG52YXIgZmV0Y2ggPSAoaW5wdXQsIHJlcXVlc3RJbml0ID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB1c2VGZXRjaChpbnB1dCwgYXVnbWVudFJlcXVlc3RJbml0KHJlcXVlc3RJbml0KSk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdFBhcmFtZXRlcnMgPSBjcmVhdGVGZXRjaFJlcXVlc3RQYXJhbWV0ZXJzKGlucHV0KTtcbiAgY29uc3QgZGVyaXZlZFJlcXVlc3RJbml0ID0gYXVnbWVudFJlcXVlc3RJbml0KHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgcmV0dXJuIHVzZUZldGNoKGlucHV0LnVybC5ocmVmLCBkZXJpdmVkUmVxdWVzdEluaXQpO1xufTtcblxuLy8gc3JjL2NvbnRleHQvdGV4dC50c1xudmFyIHRleHQgPSAoYm9keTIpID0+IHtcbiAgcmV0dXJuIChyZXMpID0+IHtcbiAgICByZXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgIHJlcy5ib2R5ID0gYm9keTI7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy9jb250ZXh0L3htbC50c1xudmFyIHhtbCA9IChib2R5MikgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHJlcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveG1sXCIpO1xuICAgIHJlcy5ib2R5ID0gYm9keTI7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL2dldFN0YXR1c0NvZGVDb2xvci50c1xuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUNvbG9yKHN0YXR1czIpIHtcbiAgaWYgKHN0YXR1czIgPCAzMDApIHtcbiAgICByZXR1cm4gXCIjNjlBQjMyXCIgLyogU3VjY2VzcyAqLztcbiAgfVxuICBpZiAoc3RhdHVzMiA8IDQwMCkge1xuICAgIHJldHVybiBcIiNGMEJCNEJcIiAvKiBXYXJuaW5nICovO1xuICB9XG4gIHJldHVybiBcIiNFOTVGNURcIiAvKiBEYW5nZXIgKi87XG59XG5cbi8vIHNyYy91dGlscy9sb2dnaW5nL2dldFRpbWVzdGFtcC50c1xuZnVuY3Rpb24gZ2V0VGltZXN0YW1wKCkge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICByZXR1cm4gW25vdy5nZXRIb3VycygpLCBub3cuZ2V0TWludXRlcygpLCBub3cuZ2V0U2Vjb25kcygpXS5tYXAoU3RyaW5nKS5tYXAoKGNodW5rKSA9PiBjaHVuay5zbGljZSgwLCAyKSkubWFwKChjaHVuaykgPT4gY2h1bmsucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiOlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvcHJlcGFyZVJlcXVlc3QudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXF1ZXN0LFxuICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMuYWxsKClcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2xvZ2dpbmcvcHJlcGFyZVJlc3BvbnNlLnRzXG5pbXBvcnQgeyBvYmplY3RUb0hlYWRlcnMgYXMgb2JqZWN0VG9IZWFkZXJzMiB9IGZyb20gXCJoZWFkZXJzLXBvbHlmaWxsXCI7XG5mdW5jdGlvbiBwcmVwYXJlUmVzcG9uc2UocmVzKSB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG9iamVjdFRvSGVhZGVyczIocmVzLmhlYWRlcnMpO1xuICBjb25zdCBwYXJzZWRCb2R5ID0gcGFyc2VCb2R5KHJlcy5ib2R5LCByZXNwb25zZUhlYWRlcnMpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlcyxcbiAgICBib2R5OiBwYXJzZWRCb2R5XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcInBhdGgtdG8tcmVnZXhwXCI7XG5pbXBvcnQgeyBnZXRDbGVhblVybCB9IGZyb20gXCJAbXN3anMvaW50ZXJjZXB0b3JzL2xpYi91dGlscy9nZXRDbGVhblVybC5qc1wiO1xuXG4vLyBzcmMvdXRpbHMvdXJsL2NsZWFuVXJsLnRzXG52YXIgUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQID0gL1tcXD98I10uKiQvZztcbmZ1bmN0aW9uIGdldFNlYXJjaFBhcmFtcyhwYXRoKSB7XG4gIHJldHVybiBuZXcgVVJMKGAvJHtwYXRofWAsIFwiaHR0cDovL2xvY2FsaG9zdFwiKS5zZWFyY2hQYXJhbXM7XG59XG5mdW5jdGlvbiBjbGVhblVybChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoUkVEVU5EQU5UX0NIQVJBQ1RFUlNfRVhQLCBcIlwiKTtcbn1cblxuLy8gc3JjL3V0aWxzL3VybC9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG5cbi8vIHNyYy91dGlscy91cmwvZ2V0QWJzb2x1dGVVcmwudHNcbmZ1bmN0aW9uIGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpIHtcbiAgaWYgKGlzQWJzb2x1dGVVcmwocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiKlwiKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGNvbnN0IG9yaWdpbiA9IGJhc2VVcmwgfHwgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJhc2VVUkk7XG4gIHJldHVybiBvcmlnaW4gPyBkZWNvZGVVUkkobmV3IFVSTChlbmNvZGVVUkkocGF0aCksIG9yaWdpbikuaHJlZikgOiBwYXRoO1xufVxuXG4vLyBzcmMvdXRpbHMvbWF0Y2hpbmcvbm9ybWFsaXplUGF0aC50c1xuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoLCBiYXNlVXJsKSB7XG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgY29uc3QgbWF5YmVBYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsKHBhdGgsIGJhc2VVcmwpO1xuICByZXR1cm4gY2xlYW5VcmwobWF5YmVBYnNvbHV0ZVVybCk7XG59XG5cbi8vIHNyYy91dGlscy9tYXRjaGluZy9tYXRjaFJlcXVlc3RVcmwudHNcbmZ1bmN0aW9uIGNvZXJjZVBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKFxuICAgIC8oWzphLXpBLVpfLV0qKShcXCp7MSwyfSkrL2csXG4gICAgKF8sIHBhcmFtZXRlck5hbWUsIHdpbGRjYXJkKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gXCIoLiopXCI7XG4gICAgICBpZiAoIXBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1ldGVyTmFtZS5zdGFydHNXaXRoKFwiOlwiKSA/IGAke3BhcmFtZXRlck5hbWV9JHt3aWxkY2FyZH1gIDogYCR7cGFyYW1ldGVyTmFtZX0ke2V4cHJlc3Npb259YDtcbiAgICB9XG4gICkucmVwbGFjZSgvKFteXFwvXSkoOikoPz1cXGQrKS8sIFwiJDFcXFxcJDJcIikucmVwbGFjZSgvXihbXlxcL10rKSg6KSg/PVxcL1xcLykvLCBcIiQxXFxcXCQyXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hSZXF1ZXN0VXJsKHVybCwgcGF0aCwgYmFzZVVybCkge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aCwgYmFzZVVybCk7XG4gIGNvbnN0IGNsZWFuUGF0aCA9IHR5cGVvZiBub3JtYWxpemVkUGF0aCA9PT0gXCJzdHJpbmdcIiA/IGNvZXJjZVBhdGgobm9ybWFsaXplZFBhdGgpIDogbm9ybWFsaXplZFBhdGg7XG4gIGNvbnN0IGNsZWFuVXJsMiA9IGdldENsZWFuVXJsKHVybCk7XG4gIGNvbnN0IHJlc3VsdCA9IG1hdGNoKGNsZWFuUGF0aCwgeyBkZWNvZGU6IGRlY29kZVVSSUNvbXBvbmVudCB9KShjbGVhblVybDIpO1xuICBjb25zdCBwYXJhbXMgPSByZXN1bHQgJiYgcmVzdWx0LnBhcmFtcyB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiByZXN1bHQgIT09IGZhbHNlLFxuICAgIHBhcmFtc1xuICB9O1xufVxuXG4vLyBzcmMvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIudHNcbmltcG9ydCB7IEhlYWRlcnMgYXMgSGVhZGVyczQgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xuXG4vLyBzcmMvcmVzcG9uc2UudHNcbmltcG9ydCB7IEhlYWRlcnMgYXMgSGVhZGVyczMgfSBmcm9tIFwiaGVhZGVycy1wb2x5ZmlsbFwiO1xuXG4vLyBzcmMvdXRpbHMvaW50ZXJuYWwvY29tcG9zZS50c1xuZnVuY3Rpb24gY29tcG9zZSguLi5mbnMpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2VSaWdodCgobGVmdEZuLCByaWdodEZuKSA9PiB7XG4gICAgICByZXR1cm4gbGVmdEZuIGluc3RhbmNlb2YgUHJvbWlzZSA/IFByb21pc2UucmVzb2x2ZShsZWZ0Rm4pLnRoZW4ocmlnaHRGbikgOiByaWdodEZuKGxlZnRGbik7XG4gICAgfSwgYXJnc1swXSk7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9OZXR3b3JrRXJyb3IudHNcbnZhciBOZXR3b3JrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiTmV0d29ya0Vycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNwb25zZS50c1xudmFyIGRlZmF1bHRSZXNwb25zZSA9IHtcbiAgc3RhdHVzOiAyMDAsXG4gIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgYm9keTogbnVsbCxcbiAgZGVsYXk6IDAsXG4gIG9uY2U6IGZhbHNlLFxuICBwYXNzdGhyb3VnaDogZmFsc2Vcbn07XG52YXIgZGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKHJlc3BvbnNlT3ZlcnJpZGVzLCBkZWZhdWx0VHJhbnNmb3JtZXJzID0gZGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJzKSB7XG4gIHJldHVybiBhc3luYyAoLi4udHJhbnNmb3JtZXJzKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgZGVmYXVsdFJlc3BvbnNlLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVyczMoe1xuICAgICAgICAgIFwieC1wb3dlcmVkLWJ5XCI6IFwibXN3XCJcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNwb25zZU92ZXJyaWRlc1xuICAgICk7XG4gICAgY29uc3QgcmVzb2x2ZWRUcmFuc2Zvcm1lcnMgPSBbXG4gICAgICAuLi5kZWZhdWx0VHJhbnNmb3JtZXJzLFxuICAgICAgLi4udHJhbnNmb3JtZXJzXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgcmVzb2x2ZWRSZXNwb25zZSA9IHJlc29sdmVkVHJhbnNmb3JtZXJzLmxlbmd0aCA+IDAgPyBjb21wb3NlKC4uLnJlc29sdmVkVHJhbnNmb3JtZXJzKShpbml0aWFsUmVzcG9uc2UpIDogaW5pdGlhbFJlc3BvbnNlO1xuICAgIHJldHVybiByZXNvbHZlZFJlc3BvbnNlO1xuICB9O1xufVxudmFyIHJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVSZXNwb25zZUNvbXBvc2l0aW9uKCksIHtcbiAgb25jZTogY3JlYXRlUmVzcG9uc2VDb21wb3NpdGlvbih7IG9uY2U6IHRydWUgfSksXG4gIG5ldHdvcmtFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IE5ldHdvcmtFcnJvcihtZXNzYWdlKTtcbiAgfVxufSk7XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC9nZXRDYWxsRnJhbWUudHNcbnZhciBTT1VSQ0VfRlJBTUUgPSAvW1xcL1xcXFxdbXN3W1xcL1xcXFxdc3JjW1xcL1xcXFxdKC4rKS87XG52YXIgQlVJTERfRlJBTUUgPSAvKG5vZGVfbW9kdWxlcyk/W1xcL1xcXFxdbGliW1xcL1xcXFxdKHVtZHxlc218aWllZnxjanMpW1xcL1xcXFxdfF5bXlxcL1xcXFxdKiQvO1xuZnVuY3Rpb24gZ2V0Q2FsbEZyYW1lKGVycm9yMikge1xuICBjb25zdCBzdGFjayA9IGVycm9yMi5zdGFjaztcbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmcmFtZXMgPSBzdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKTtcbiAgY29uc3QgZGVjbGFyYXRpb25GcmFtZSA9IGZyYW1lcy5maW5kKChmcmFtZSkgPT4ge1xuICAgIHJldHVybiAhKFNPVVJDRV9GUkFNRS50ZXN0KGZyYW1lKSB8fCBCVUlMRF9GUkFNRS50ZXN0KGZyYW1lKSk7XG4gIH0pO1xuICBpZiAoIWRlY2xhcmF0aW9uRnJhbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVjbGFyYXRpb25QYXRoID0gZGVjbGFyYXRpb25GcmFtZS5yZXBsYWNlKC9cXHMqYXQgW14oKV0qXFwoKFteKV0rKVxcKS8sIFwiJDFcIikucmVwbGFjZSgvXkAvLCBcIlwiKTtcbiAgcmV0dXJuIGRlY2xhcmF0aW9uUGF0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2ludGVybmFsL2lzSXRlcmFibGUudHNcbmZ1bmN0aW9uIGlzSXRlcmFibGUoZm4pIHtcbiAgaWYgKCFmbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGZuW1N5bWJvbC5pdGVyYXRvcl0gPT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvaGFuZGxlcnMvUmVxdWVzdEhhbmRsZXIudHNcbnZhciBkZWZhdWx0Q29udGV4dCA9IHtcbiAgc3RhdHVzLFxuICBzZXQsXG4gIGRlbGF5LFxuICBmZXRjaFxufTtcbnZhciBSZXF1ZXN0SGFuZGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc2hvdWxkU2tpcCA9IGZhbHNlO1xuICAgIHRoaXMuY3R4ID0gb3B0aW9ucy5jdHggfHwgZGVmYXVsdENvbnRleHQ7XG4gICAgdGhpcy5yZXNvbHZlciA9IG9wdGlvbnMucmVzb2x2ZXI7XG4gICAgY29uc3QgY2FsbEZyYW1lID0gZ2V0Q2FsbEZyYW1lKG5ldyBFcnJvcigpKTtcbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICAuLi5vcHRpb25zLmluZm8sXG4gICAgICBjYWxsRnJhbWVcbiAgICB9O1xuICB9XG4gIHBhcnNlKF9yZXF1ZXN0LCBfcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0ZXN0KHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRoaXMucGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpLFxuICAgICAgcmVzb2x1dGlvbkNvbnRleHRcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgX3BhcnNlZFJlc3VsdCkge1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIG1hcmtBc1NraXBwZWQoc2hvdWxkU2tpcCA9IHRydWUpIHtcbiAgICB0aGlzLnNob3VsZFNraXAgPSBzaG91bGRTa2lwO1xuICB9XG4gIGFzeW5jIHJ1bihyZXF1ZXN0LCByZXNvbHV0aW9uQ29udGV4dCkge1xuICAgIGlmICh0aGlzLnNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRSZXN1bHQgPSB0aGlzLnBhcnNlKHJlcXVlc3QsIHJlc29sdXRpb25Db250ZXh0KTtcbiAgICBjb25zdCBzaG91bGRJbnRlcmNlcHQgPSB0aGlzLnByZWRpY2F0ZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBwYXJzZWRSZXN1bHQsXG4gICAgICByZXNvbHV0aW9uQ29udGV4dFxuICAgICk7XG4gICAgaWYgKCFzaG91bGRJbnRlcmNlcHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNSZXF1ZXN0ID0gdGhpcy5nZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCk7XG4gICAgY29uc3QgZXhlY3V0ZVJlc29sdmVyID0gdGhpcy53cmFwUmVzb2x2ZXIodGhpcy5yZXNvbHZlcik7XG4gICAgY29uc3QgbW9ja2VkUmVzcG9uc2UgPSBhd2FpdCBleGVjdXRlUmVzb2x2ZXIoXG4gICAgICBwdWJsaWNSZXF1ZXN0LFxuICAgICAgcmVzcG9uc2UsXG4gICAgICB0aGlzLmN0eFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhlY3V0aW9uUmVzdWx0KFxuICAgICAgcGFyc2VkUmVzdWx0LFxuICAgICAgcHVibGljUmVxdWVzdCxcbiAgICAgIG1vY2tlZFJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICB3cmFwUmVzb2x2ZXIocmVzb2x2ZXIpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzb2x2ZXJHZW5lcmF0b3IgfHwgYXdhaXQgcmVzb2x2ZXIocmVxLCByZXMsIGN0eCk7XG4gICAgICBpZiAoaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IHJlc3VsdFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgICAgICBjb25zdCBuZXh0UmVzcG9uc2UgPSBhd2FpdCB2YWx1ZTtcbiAgICAgICAgaWYgKCFuZXh0UmVzcG9uc2UgJiYgZG9uZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyR2VuZXJhdG9yUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlckdlbmVyYXRvcikge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZXJHZW5lcmF0b3IgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlckdlbmVyYXRvclJlc3VsdCA9IG5leHRSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIG5leHRSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBjcmVhdGVFeGVjdXRpb25SZXN1bHQocGFyc2VkUmVzdWx0LCByZXF1ZXN0LCByZXNwb25zZTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlcjogdGhpcyxcbiAgICAgIHBhcnNlZFJlc3VsdDogcGFyc2VkUmVzdWx0IHx8IG51bGwsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlMiB8fCBudWxsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2hhbmRsZXJzL1Jlc3RIYW5kbGVyLnRzXG52YXIgcmVzdENvbnRleHQgPSB7XG4gIC4uLmRlZmF1bHRDb250ZXh0LFxuICBjb29raWUsXG4gIGJvZHksXG4gIHRleHQsXG4gIGpzb24sXG4gIHhtbFxufTtcbnZhciBSZXN0UmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgTW9ja2VkUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QsIHBhcmFtcykge1xuICAgIHN1cGVyKHJlcXVlc3QudXJsLCB7XG4gICAgICAuLi5yZXF1ZXN0LFxuICAgICAgYm9keTogcmVxdWVzdFtcIl9ib2R5XCJdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5pZCA9IHJlcXVlc3QuaWQ7XG4gIH1cbn07XG52YXIgUmVzdEhhbmRsZXIgPSBjbGFzcyBleHRlbmRzIFJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IobWV0aG9kLCBwYXRoLCByZXNvbHZlcikge1xuICAgIHN1cGVyKHtcbiAgICAgIGluZm86IHtcbiAgICAgICAgaGVhZGVyOiBgJHttZXRob2R9ICR7cGF0aH1gLFxuICAgICAgICBwYXRoLFxuICAgICAgICBtZXRob2RcbiAgICAgIH0sXG4gICAgICBjdHg6IHJlc3RDb250ZXh0LFxuICAgICAgcmVzb2x2ZXJcbiAgICB9KTtcbiAgICB0aGlzLmNoZWNrUmVkdW5kYW50UXVlcnlQYXJhbWV0ZXJzKCk7XG4gIH1cbiAgY2hlY2tSZWR1bmRhbnRRdWVyeVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgeyBtZXRob2QsIHBhdGggfSA9IHRoaXMuaW5mbztcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBjbGVhblVybChwYXRoKTtcbiAgICBpZiAodXJsID09PSBwYXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IGdldFNlYXJjaFBhcmFtcyhwYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IFtdO1xuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBwYXJhbU5hbWUpID0+IHtcbiAgICAgIHF1ZXJ5UGFyYW1zLnB1c2gocGFyYW1OYW1lKTtcbiAgICB9KTtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYEZvdW5kIGEgcmVkdW5kYW50IHVzYWdlIG9mIHF1ZXJ5IHBhcmFtZXRlcnMgaW4gdGhlIHJlcXVlc3QgaGFuZGxlciBVUkwgZm9yIFwiJHttZXRob2R9ICR7cGF0aH1cIi4gUGxlYXNlIG1hdGNoIGFnYWluc3QgYSBwYXRoIGluc3RlYWQgYW5kIGFjY2VzcyBxdWVyeSBwYXJhbWV0ZXJzIGluIHRoZSByZXNwb25zZSByZXNvbHZlciBmdW5jdGlvbiB1c2luZyBcInJlcS51cmwuc2VhcmNoUGFyYW1zXCIuYFxuICAgICk7XG4gIH1cbiAgcGFyc2UocmVxdWVzdCwgcmVzb2x1dGlvbkNvbnRleHQpIHtcbiAgICByZXR1cm4gbWF0Y2hSZXF1ZXN0VXJsKFxuICAgICAgcmVxdWVzdC51cmwsXG4gICAgICB0aGlzLmluZm8ucGF0aCxcbiAgICAgIHJlc29sdXRpb25Db250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByZXNvbHV0aW9uQ29udGV4dC5iYXNlVXJsXG4gICAgKTtcbiAgfVxuICBnZXRQdWJsaWNSZXF1ZXN0KHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIHJldHVybiBuZXcgUmVzdFJlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0LnBhcmFtcyB8fCB7fSk7XG4gIH1cbiAgcHJlZGljYXRlKHJlcXVlc3QsIHBhcnNlZFJlc3VsdCkge1xuICAgIGNvbnN0IG1hdGNoZXNNZXRob2QgPSB0aGlzLmluZm8ubWV0aG9kIGluc3RhbmNlb2YgUmVnRXhwID8gdGhpcy5pbmZvLm1ldGhvZC50ZXN0KHJlcXVlc3QubWV0aG9kKSA6IGlzU3RyaW5nRXF1YWwodGhpcy5pbmZvLm1ldGhvZCwgcmVxdWVzdC5tZXRob2QpO1xuICAgIHJldHVybiBtYXRjaGVzTWV0aG9kICYmIHBhcnNlZFJlc3VsdC5tYXRjaGVzO1xuICB9XG4gIGxvZyhyZXF1ZXN0LCByZXNwb25zZTIpIHtcbiAgICBjb25zdCBwdWJsaWNVcmwgPSBnZXRQdWJsaWNVcmxGcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBjb25zdCBsb2dnZWRSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgbG9nZ2VkUmVzcG9uc2UgPSBwcmVwYXJlUmVzcG9uc2UocmVzcG9uc2UyKTtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldFN0YXR1c0NvZGVDb2xvcihyZXNwb25zZTIuc3RhdHVzKTtcbiAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcIiVzICVzICVzICglYyVzJWMpXCIpLFxuICAgICAgZ2V0VGltZXN0YW1wKCksXG4gICAgICByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIHB1YmxpY1VybCxcbiAgICAgIGBjb2xvcjoke3N0YXR1c0NvbG9yfWAsXG4gICAgICBgJHtyZXNwb25zZTIuc3RhdHVzfSAke3Jlc3BvbnNlMi5zdGF0dXNUZXh0fWAsXG4gICAgICBcImNvbG9yOmluaGVyaXRcIlxuICAgICk7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0XCIsIGxvZ2dlZFJlcXVlc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiSGFuZGxlcjpcIiwgdGhpcyk7XG4gICAgY29uc29sZS5sb2coXCJSZXNwb25zZVwiLCBsb2dnZWRSZXNwb25zZSk7XG4gICAgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG59O1xuXG4vLyBzcmMvY29udGV4dC9maWVsZC50c1xuaW1wb3J0IHsgaW52YXJpYW50IGFzIGludmFyaWFudDIgfSBmcm9tIFwib3V0dmFyaWFudFwiO1xudmFyIGZpZWxkID0gKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkgPT4ge1xuICByZXR1cm4gKHJlcykgPT4ge1xuICAgIHZhbGlkYXRlRmllbGROYW1lKGZpZWxkTmFtZSk7XG4gICAgY29uc3QgcHJldkJvZHkgPSBqc29uUGFyc2UocmVzLmJvZHkpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRCb2R5ID0gbWVyZ2VSaWdodChwcmV2Qm9keSwgeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICByZXR1cm4ganNvbihuZXh0Qm9keSkocmVzKTtcbiAgfTtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkTmFtZShmaWVsZE5hbWUpIHtcbiAgaW52YXJpYW50MihcbiAgICBmaWVsZE5hbWUudHJpbSgpICE9PSBcIlwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICBcIkZhaWxlZCB0byBzZXQgYSBjdXN0b20gZmllbGQgb24gYSBHcmFwaFFMIHJlc3BvbnNlOiBmaWVsZCBuYW1lIGNhbm5vdCBiZSBlbXB0eS5cIlxuICAgIClcbiAgKTtcbiAgaW52YXJpYW50MihcbiAgICBmaWVsZE5hbWUgIT09IFwiZGF0YVwiLFxuICAgIGRldlV0aWxzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAnRmFpbGVkIHRvIHNldCBhIGN1c3RvbSBcIiVzXCIgZmllbGQgb24gYSBtb2NrZWQgR3JhcGhRTCByZXNwb25zZTogZm9yYmlkZGVuIGZpZWxkIG5hbWUuIERpZCB5b3UgbWVhbiB0byBjYWxsIFwiY3R4LmRhdGEoKVwiIGluc3RlYWQ/JyxcbiAgICAgIGZpZWxkTmFtZVxuICAgIClcbiAgKTtcbiAgaW52YXJpYW50MihcbiAgICBmaWVsZE5hbWUgIT09IFwiZXJyb3JzXCIsXG4gICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICdGYWlsZWQgdG8gc2V0IGEgY3VzdG9tIFwiJXNcIiBmaWVsZCBvbiBhIG1vY2tlZCBHcmFwaFFMIHJlc3BvbnNlOiBmb3JiaWRkZW4gZmllbGQgbmFtZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgXCJjdHguZXJyb3JzKClcIiBpbnN0ZWFkPycsXG4gICAgICBmaWVsZE5hbWVcbiAgICApXG4gICk7XG4gIGludmFyaWFudDIoXG4gICAgZmllbGROYW1lICE9PSBcImV4dGVuc2lvbnNcIixcbiAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgJ0ZhaWxlZCB0byBzZXQgYSBjdXN0b20gXCIlc1wiIGZpZWxkIG9uIGEgbW9ja2VkIEdyYXBoUUwgcmVzcG9uc2U6IGZvcmJpZGRlbiBmaWVsZCBuYW1lLiBEaWQgeW91IG1lYW4gdG8gY2FsbCBcImN0eC5leHRlbnNpb25zKClcIiBpbnN0ZWFkPycsXG4gICAgICBmaWVsZE5hbWVcbiAgICApXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbC90cnlDYXRjaC50c1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9uRXhjZXB0aW9uKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBvbkV4Y2VwdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25FeGNlcHRpb24oZXJyb3IyKTtcbiAgfVxufVxuXG4vLyBzcmMvaGFuZGxlcnMvR3JhcGhRTEhhbmRsZXIudHNcbnZhciBncmFwaHFsQ29udGV4dCA9IHtcbiAgLi4uZGVmYXVsdENvbnRleHQsXG4gIGRhdGEsXG4gIGV4dGVuc2lvbnMsXG4gIGVycm9ycyxcbiAgY29va2llLFxuICBmaWVsZFxufTtcbmZ1bmN0aW9uIGlzRG9jdW1lbnROb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJraW5kXCIgaW4gdmFsdWUgJiYgXCJkZWZpbml0aW9uc1wiIGluIHZhbHVlO1xufVxudmFyIEdyYXBoUUxSZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBNb2NrZWRSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IocmVxdWVzdCwgdmFyaWFibGVzLCBvcGVyYXRpb25OYW1lKSB7XG4gICAgc3VwZXIocmVxdWVzdC51cmwsIHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBib2R5OiByZXF1ZXN0W1wiX2JvZHlcIl1cbiAgICB9KTtcbiAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICB0aGlzLm9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lO1xuICB9XG59O1xudmFyIEdyYXBoUUxIYW5kbGVyID0gY2xhc3MgZXh0ZW5kcyBSZXF1ZXN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvblR5cGUsIG9wZXJhdGlvbk5hbWUsIGVuZHBvaW50LCByZXNvbHZlcikge1xuICAgIGxldCByZXNvbHZlZE9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lO1xuICAgIGlmIChpc0RvY3VtZW50Tm9kZShvcGVyYXRpb25OYW1lKSkge1xuICAgICAgY29uc3QgcGFyc2VkTm9kZSA9IHBhcnNlRG9jdW1lbnROb2RlKG9wZXJhdGlvbk5hbWUpO1xuICAgICAgaWYgKHBhcnNlZE5vZGUub3BlcmF0aW9uVHlwZSAhPT0gb3BlcmF0aW9uVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgYSBHcmFwaFFMIGhhbmRsZXI6IHByb3ZpZGVkIGEgRG9jdW1lbnROb2RlIHdpdGggYSBtaXNtYXRjaGVkIG9wZXJhdGlvbiB0eXBlIChleHBlY3RlZCBcIiR7b3BlcmF0aW9uVHlwZX1cIiwgYnV0IGdvdCBcIiR7cGFyc2VkTm9kZS5vcGVyYXRpb25UeXBlfVwiKS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlZE5vZGUub3BlcmF0aW9uTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgYSBHcmFwaFFMIGhhbmRsZXI6IHByb3ZpZGVkIGEgRG9jdW1lbnROb2RlIHdpdGggbm8gb3BlcmF0aW9uIG5hbWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRPcGVyYXRpb25OYW1lID0gcGFyc2VkTm9kZS5vcGVyYXRpb25OYW1lO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBvcGVyYXRpb25UeXBlID09PSBcImFsbFwiID8gYCR7b3BlcmF0aW9uVHlwZX0gKG9yaWdpbjogJHtlbmRwb2ludC50b1N0cmluZygpfSlgIDogYCR7b3BlcmF0aW9uVHlwZX0gJHtyZXNvbHZlZE9wZXJhdGlvbk5hbWV9IChvcmlnaW46ICR7ZW5kcG9pbnQudG9TdHJpbmcoKX0pYDtcbiAgICBzdXBlcih7XG4gICAgICBpbmZvOiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgb3BlcmF0aW9uVHlwZSxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogcmVzb2x2ZWRPcGVyYXRpb25OYW1lXG4gICAgICB9LFxuICAgICAgY3R4OiBncmFwaHFsQ29udGV4dCxcbiAgICAgIHJlc29sdmVyXG4gICAgfSk7XG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICB9XG4gIHBhcnNlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdHJ5Q2F0Y2goXG4gICAgICAoKSA9PiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpLFxuICAgICAgKGVycm9yMikgPT4gY29uc29sZS5lcnJvcihlcnJvcjIubWVzc2FnZSlcbiAgICApO1xuICB9XG4gIGdldFB1YmxpY1JlcXVlc3QocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gbmV3IEdyYXBoUUxSZXF1ZXN0KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIChfYSA9IHBhcnNlZFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVzdWx0LnZhcmlhYmxlcykgIT0gbnVsbCA/IF9hIDoge30sXG4gICAgICAoX2IgPSBwYXJzZWRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25OYW1lKSAhPSBudWxsID8gX2IgOiBcIlwiXG4gICAgKTtcbiAgfVxuICBwcmVkaWNhdGUocmVxdWVzdCwgcGFyc2VkUmVzdWx0KSB7XG4gICAgaWYgKCFwYXJzZWRSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSAmJiB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZSAhPT0gXCJhbGxcIikge1xuICAgICAgY29uc3QgcHVibGljVXJsID0gZ2V0UHVibGljVXJsRnJvbVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICBkZXZVdGlscy53YXJuKGBGYWlsZWQgdG8gaW50ZXJjZXB0IGEgR3JhcGhRTCByZXF1ZXN0IGF0IFwiJHtyZXF1ZXN0Lm1ldGhvZH0gJHtwdWJsaWNVcmx9XCI6IGFub255bW91cyBHcmFwaFFMIG9wZXJhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cbkNvbnNpZGVyIG5hbWluZyB0aGlzIG9wZXJhdGlvbiBvciB1c2luZyBcImdyYXBocWwub3BlcmF0aW9uKClcIiByZXF1ZXN0IGhhbmRsZXIgdG8gaW50ZXJjZXB0IEdyYXBoUUwgcmVxdWVzdHMgcmVnYXJkbGVzcyBvZiB0aGVpciBvcGVyYXRpb24gbmFtZS90eXBlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbXN3anMuaW8vZG9jcy9hcGkvZ3JhcGhxbC9vcGVyYXRpb24gICAgICBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaGFzTWF0Y2hpbmdVcmwgPSBtYXRjaFJlcXVlc3RVcmwocmVxdWVzdC51cmwsIHRoaXMuZW5kcG9pbnQpO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nT3BlcmF0aW9uVHlwZSA9IHRoaXMuaW5mby5vcGVyYXRpb25UeXBlID09PSBcImFsbFwiIHx8IHBhcnNlZFJlc3VsdC5vcGVyYXRpb25UeXBlID09PSB0aGlzLmluZm8ub3BlcmF0aW9uVHlwZTtcbiAgICBjb25zdCBoYXNNYXRjaGluZ09wZXJhdGlvbk5hbWUgPSB0aGlzLmluZm8ub3BlcmF0aW9uTmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCA/IHRoaXMuaW5mby5vcGVyYXRpb25OYW1lLnRlc3QocGFyc2VkUmVzdWx0Lm9wZXJhdGlvbk5hbWUgfHwgXCJcIikgOiBwYXJzZWRSZXN1bHQub3BlcmF0aW9uTmFtZSA9PT0gdGhpcy5pbmZvLm9wZXJhdGlvbk5hbWU7XG4gICAgcmV0dXJuIGhhc01hdGNoaW5nVXJsLm1hdGNoZXMgJiYgaGFzTWF0Y2hpbmdPcGVyYXRpb25UeXBlICYmIGhhc01hdGNoaW5nT3BlcmF0aW9uTmFtZTtcbiAgfVxuICBsb2cocmVxdWVzdCwgcmVzcG9uc2UyLCBwYXJzZWRSZXF1ZXN0KSB7XG4gICAgY29uc3QgbG9nZ2VkUmVxdWVzdCA9IHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGxvZ2dlZFJlc3BvbnNlID0gcHJlcGFyZVJlc3BvbnNlKHJlc3BvbnNlMik7XG4gICAgY29uc3Qgc3RhdHVzQ29sb3IgPSBnZXRTdGF0dXNDb2RlQ29sb3IocmVzcG9uc2UyLnN0YXR1cyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSAocGFyc2VkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VkUmVxdWVzdC5vcGVyYXRpb25OYW1lKSA/IGAke3BhcnNlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFJlcXVlc3Qub3BlcmF0aW9uVHlwZX0gJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvbk5hbWV9YCA6IGBhbm9ueW1vdXMgJHtwYXJzZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZWRSZXF1ZXN0Lm9wZXJhdGlvblR5cGV9YDtcbiAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcIiVzICVzICglYyVzJWMpXCIpLFxuICAgICAgZ2V0VGltZXN0YW1wKCksXG4gICAgICBgJHtyZXF1ZXN0SW5mb31gLFxuICAgICAgYGNvbG9yOiR7c3RhdHVzQ29sb3J9YCxcbiAgICAgIGAke3Jlc3BvbnNlMi5zdGF0dXN9ICR7cmVzcG9uc2UyLnN0YXR1c1RleHR9YCxcbiAgICAgIFwiY29sb3I6aW5oZXJpdFwiXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3Q6XCIsIGxvZ2dlZFJlcXVlc3QpO1xuICAgIGNvbnNvbGUubG9nKFwiSGFuZGxlcjpcIiwgdGhpcyk7XG4gICAgY29uc29sZS5sb2coXCJSZXNwb25zZTpcIiwgbG9nZ2VkUmVzcG9uc2UpO1xuICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3JlcXVlc3Qvb25VbmhhbmRsZWRSZXF1ZXN0LnRzXG52YXIgTUFYX01BVENIX1NDT1JFID0gMztcbnZhciBNQVhfU1VHR0VTVElPTl9DT1VOVCA9IDQ7XG52YXIgVFlQRV9NQVRDSF9ERUxUQSA9IDAuNTtcbmZ1bmN0aW9uIGdyb3VwSGFuZGxlcnNCeVR5cGUoaGFuZGxlcnMpIHtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlZHVjZShcbiAgICAoZ3JvdXBzLCBoYW5kbGVyKSA9PiB7XG4gICAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIFJlc3RIYW5kbGVyKSB7XG4gICAgICAgIGdyb3Vwcy5yZXN0LnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIEdyYXBoUUxIYW5kbGVyKSB7XG4gICAgICAgIGdyb3Vwcy5ncmFwaHFsLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sXG4gICAge1xuICAgICAgcmVzdDogW10sXG4gICAgICBncmFwaHFsOiBbXVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlc3RIYW5kbGVyU2NvcmUoKSB7XG4gIHJldHVybiAocmVxdWVzdCwgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHsgcGF0aCwgbWV0aG9kIH0gPSBoYW5kbGVyLmluZm87XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHAgfHwgbWV0aG9kIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IGhhc1NhbWVNZXRob2QgPSBpc1N0cmluZ0VxdWFsKHJlcXVlc3QubWV0aG9kLCBtZXRob2QpO1xuICAgIGNvbnN0IG1ldGhvZFNjb3JlRGVsdGEgPSBoYXNTYW1lTWV0aG9kID8gVFlQRV9NQVRDSF9ERUxUQSA6IDA7XG4gICAgY29uc3QgcmVxdWVzdFB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IHNjb3JlID0gZ2V0U3RyaW5nTWF0Y2hTY29yZShyZXF1ZXN0UHVibGljVXJsLCBwYXRoKTtcbiAgICByZXR1cm4gc2NvcmUgLSBtZXRob2RTY29yZURlbHRhO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0R3JhcGhRTEhhbmRsZXJTY29yZShwYXJzZWRRdWVyeSkge1xuICByZXR1cm4gKF8sIGhhbmRsZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvbk5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgeyBvcGVyYXRpb25UeXBlLCBvcGVyYXRpb25OYW1lIH0gPSBoYW5kbGVyLmluZm87XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb25OYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGNvbnN0IGhhc1NhbWVPcGVyYXRpb25UeXBlID0gcGFyc2VkUXVlcnkub3BlcmF0aW9uVHlwZSA9PT0gb3BlcmF0aW9uVHlwZTtcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlU2NvcmVEZWx0YSA9IGhhc1NhbWVPcGVyYXRpb25UeXBlID8gVFlQRV9NQVRDSF9ERUxUQSA6IDA7XG4gICAgY29uc3Qgc2NvcmUgPSBnZXRTdHJpbmdNYXRjaFNjb3JlKHBhcnNlZFF1ZXJ5Lm9wZXJhdGlvbk5hbWUsIG9wZXJhdGlvbk5hbWUpO1xuICAgIHJldHVybiBzY29yZSAtIG9wZXJhdGlvblR5cGVTY29yZURlbHRhO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3VnZ2VzdGVkSGFuZGxlcihyZXF1ZXN0LCBoYW5kbGVycywgZ2V0U2NvcmUpIHtcbiAgY29uc3Qgc3VnZ2VzdGVkSGFuZGxlcnMgPSBoYW5kbGVycy5yZWR1Y2UoKHN1Z2dlc3Rpb25zLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3Qgc2NvcmUgPSBnZXRTY29yZShyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICByZXR1cm4gc3VnZ2VzdGlvbnMuY29uY2F0KFtbc2NvcmUsIGhhbmRsZXJdXSk7XG4gIH0sIFtdKS5zb3J0KChbbGVmdFNjb3JlXSwgW3JpZ2h0U2NvcmVdKSA9PiBsZWZ0U2NvcmUgLSByaWdodFNjb3JlKS5maWx0ZXIoKFtzY29yZV0pID0+IHNjb3JlIDw9IE1BWF9NQVRDSF9TQ09SRSkuc2xpY2UoMCwgTUFYX1NVR0dFU1RJT05fQ09VTlQpLm1hcCgoWywgaGFuZGxlcl0pID0+IGhhbmRsZXIpO1xuICByZXR1cm4gc3VnZ2VzdGVkSGFuZGxlcnM7XG59XG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRIYW5kbGVyc01lc3NhZ2UoaGFuZGxlcnMpIHtcbiAgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gYERpZCB5b3UgbWVhbiB0byByZXF1ZXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlc291cmNlcyBpbnN0ZWFkP1xuXG4ke2hhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gYCAgXFx1MjAyMiAke2hhbmRsZXIuaW5mby5oZWFkZXJ9YCkuam9pbihcIlxcblwiKX1gO1xuICB9XG4gIHJldHVybiBgRGlkIHlvdSBtZWFuIHRvIHJlcXVlc3QgXCIke2hhbmRsZXJzWzBdLmluZm8uaGVhZGVyfVwiIGluc3RlYWQ/YDtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVxdWVzdChyZXF1ZXN0LCBoYW5kbGVycywgc3RyYXRlZ3kgPSBcIndhcm5cIikge1xuICBjb25zdCBwYXJzZWRHcmFwaFFMUXVlcnkgPSB0cnlDYXRjaCgoKSA9PiBwYXJzZUdyYXBoUUxSZXF1ZXN0KHJlcXVlc3QpKTtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVIYW5kbGVyU3VnZ2VzdGlvbigpIHtcbiAgICBjb25zdCBoYW5kbGVyR3JvdXBzID0gZ3JvdXBIYW5kbGVyc0J5VHlwZShoYW5kbGVycyk7XG4gICAgY29uc3QgcmVsZXZhbnRIYW5kbGVycyA9IHBhcnNlZEdyYXBoUUxRdWVyeSA/IGhhbmRsZXJHcm91cHMuZ3JhcGhxbCA6IGhhbmRsZXJHcm91cHMucmVzdDtcbiAgICBjb25zdCBzdWdnZXN0ZWRIYW5kbGVycyA9IGdldFN1Z2dlc3RlZEhhbmRsZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVsZXZhbnRIYW5kbGVycyxcbiAgICAgIHBhcnNlZEdyYXBoUUxRdWVyeSA/IGdldEdyYXBoUUxIYW5kbGVyU2NvcmUocGFyc2VkR3JhcGhRTFF1ZXJ5KSA6IGdldFJlc3RIYW5kbGVyU2NvcmUoKVxuICAgICk7XG4gICAgcmV0dXJuIHN1Z2dlc3RlZEhhbmRsZXJzLmxlbmd0aCA+IDAgPyBnZXRTdWdnZXN0ZWRIYW5kbGVyc01lc3NhZ2Uoc3VnZ2VzdGVkSGFuZGxlcnMpIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVVuaGFuZGxlZFJlcXVlc3RNZXNzYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybEZyb21SZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXIgPSBwYXJzZWRHcmFwaFFMUXVlcnkgPyBgJHtwYXJzZWRHcmFwaFFMUXVlcnkub3BlcmF0aW9uVHlwZX0gJHtwYXJzZWRHcmFwaFFMUXVlcnkub3BlcmF0aW9uTmFtZX0gKCR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfSlgIDogYCR7cmVxdWVzdC5tZXRob2R9ICR7cHVibGljVXJsfWA7XG4gICAgY29uc3QgaGFuZGxlclN1Z2dlc3Rpb24gPSBnZW5lcmF0ZUhhbmRsZXJTdWdnZXN0aW9uKCk7XG4gICAgY29uc3QgbWVzc2FnZVRlbXBsYXRlID0gW1xuICAgICAgYGNhcHR1cmVkIGEgcmVxdWVzdCB3aXRob3V0IGEgbWF0Y2hpbmcgcmVxdWVzdCBoYW5kbGVyOmAsXG4gICAgICBgICBcXHUyMDIyICR7cmVxdWVzdEhlYWRlcn1gLFxuICAgICAgaGFuZGxlclN1Z2dlc3Rpb24sXG4gICAgICBgSWYgeW91IHN0aWxsIHdpc2ggdG8gaW50ZXJjZXB0IHRoaXMgdW5oYW5kbGVkIHJlcXVlc3QsIHBsZWFzZSBjcmVhdGUgYSByZXF1ZXN0IGhhbmRsZXIgZm9yIGl0LlxuUmVhZCBtb3JlOiBodHRwczovL21zd2pzLmlvL2RvY3MvZ2V0dGluZy1zdGFydGVkL21vY2tzYFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJldHVybiBtZXNzYWdlVGVtcGxhdGUuam9pbihcIlxcblxcblwiKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVN0cmF0ZWd5KHN0cmF0ZWd5Mikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW5lcmF0ZVVuaGFuZGxlZFJlcXVlc3RNZXNzYWdlKCk7XG4gICAgc3dpdGNoIChzdHJhdGVneTIpIHtcbiAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgIGRldlV0aWxzLmVycm9yKFwiRXJyb3I6ICVzXCIsIG1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgZGV2VXRpbHMuZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICAgICdDYW5ub3QgYnlwYXNzIGEgcmVxdWVzdCB3aGVuIHVzaW5nIHRoZSBcImVycm9yXCIgc3RyYXRlZ3kgZm9yIHRoZSBcIm9uVW5oYW5kbGVkUmVxdWVzdFwiIG9wdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhcm5cIjoge1xuICAgICAgICBkZXZVdGlscy53YXJuKFwiV2FybmluZzogJXNcIiwgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJ5cGFzc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byByZWFjdCB0byBhbiB1bmhhbmRsZWQgcmVxdWVzdDogdW5rbm93biBzdHJhdGVneSBcIiVzXCIuIFBsZWFzZSBwcm92aWRlIG9uZSBvZiB0aGUgc3VwcG9ydGVkIHN0cmF0ZWdpZXMgKFwiYnlwYXNzXCIsIFwid2FyblwiLCBcImVycm9yXCIpIG9yIGEgY3VzdG9tIGNhbGxiYWNrIGZ1bmN0aW9uIGFzIHRoZSB2YWx1ZSBvZiB0aGUgXCJvblVuaGFuZGxlZFJlcXVlc3RcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHN0cmF0ZWd5MlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RyYXRlZ3kocmVxdWVzdCwge1xuICAgICAgd2FybmluZzogYXBwbHlTdHJhdGVneS5iaW5kKG51bGwsIFwid2FyblwiKSxcbiAgICAgIGVycm9yOiBhcHBseVN0cmF0ZWd5LmJpbmQobnVsbCwgXCJlcnJvclwiKVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBhcHBseVN0cmF0ZWd5KHN0cmF0ZWd5KTtcbn1cblxuLy8gc3JjL3V0aWxzL3JlcXVlc3QvcmVhZFJlc3BvbnNlQ29va2llcy50c1xuaW1wb3J0IHsgc3RvcmUgYXMgc3RvcmUyIH0gZnJvbSBcIkBtc3dqcy9jb29raWVzXCI7XG5mdW5jdGlvbiByZWFkUmVzcG9uc2VDb29raWVzKHJlcXVlc3QsIHJlc3BvbnNlMikge1xuICBzdG9yZTIuYWRkKHsgLi4ucmVxdWVzdCwgdXJsOiByZXF1ZXN0LnVybC50b1N0cmluZygpIH0sIHJlc3BvbnNlMik7XG4gIHN0b3JlMi5wZXJzaXN0KCk7XG59XG5cbi8vIHNyYy91dGlscy9oYW5kbGVSZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3QsIGhhbmRsZXJzLCBvcHRpb25zLCBlbWl0dGVyLCBoYW5kbGVSZXF1ZXN0T3B0aW9ucykge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDpzdGFydFwiLCByZXF1ZXN0KTtcbiAgaWYgKHJlcXVlc3QuaGVhZGVycy5nZXQoXCJ4LW1zdy1ieXBhc3NcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDplbmRcIiwgcmVxdWVzdCk7XG4gICAgKF9hID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLm9uUGFzc3Rocm91Z2hSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaGFuZGxlUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbbG9va3VwRXJyb3IsIGxvb2t1cFJlc3VsdF0gPSBhd2FpdCB1bnRpbCgoKSA9PiB7XG4gICAgcmV0dXJuIGdldFJlc3BvbnNlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLnJlc29sdXRpb25Db250ZXh0XG4gICAgKTtcbiAgfSk7XG4gIGlmIChsb29rdXBFcnJvcikge1xuICAgIGVtaXR0ZXIuZW1pdChcInVuaGFuZGxlZEV4Y2VwdGlvblwiLCBsb29rdXBFcnJvciwgcmVxdWVzdCk7XG4gICAgdGhyb3cgbG9va3VwRXJyb3I7XG4gIH1cbiAgY29uc3QgeyBoYW5kbGVyLCByZXNwb25zZTogcmVzcG9uc2UyIH0gPSBsb29rdXBSZXN1bHQ7XG4gIGlmICghaGFuZGxlcikge1xuICAgIG9uVW5oYW5kbGVkUmVxdWVzdChyZXF1ZXN0LCBoYW5kbGVycywgb3B0aW9ucy5vblVuaGFuZGxlZFJlcXVlc3QpO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6dW5oYW5kbGVkXCIsIHJlcXVlc3QpO1xuICAgIGVtaXR0ZXIuZW1pdChcInJlcXVlc3Q6ZW5kXCIsIHJlcXVlc3QpO1xuICAgIChfYiA9IGhhbmRsZVJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVSZXF1ZXN0T3B0aW9ucy5vblBhc3N0aHJvdWdoUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGhhbmRsZVJlcXVlc3RPcHRpb25zLCByZXF1ZXN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFyZXNwb25zZTIpIHtcbiAgICBkZXZVdGlscy53YXJuKFxuICAgICAgYEV4cGVjdGVkIHJlc3BvbnNlIHJlc29sdmVyIHRvIHJldHVybiBhIG1vY2tlZCByZXNwb25zZSBPYmplY3QsIGJ1dCBnb3QgJXMuIFRoZSBvcmlnaW5hbCByZXNwb25zZSBpcyBnb2luZyB0byBiZSB1c2VkIGluc3RlYWQuXG5cbiAgXFx1MjAyMiAlc1xuICAgICVzYCxcbiAgICAgIHJlc3BvbnNlMixcbiAgICAgIGhhbmRsZXIuaW5mby5oZWFkZXIsXG4gICAgICBoYW5kbGVyLmluZm8uY2FsbEZyYW1lXG4gICAgKTtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2MgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChyZXNwb25zZTIucGFzc3Rocm91Z2gpIHtcbiAgICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgICAoX2QgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25QYXNzdGhyb3VnaFJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlYWRSZXNwb25zZUNvb2tpZXMocmVxdWVzdCwgcmVzcG9uc2UyKTtcbiAgZW1pdHRlci5lbWl0KFwicmVxdWVzdDptYXRjaFwiLCByZXF1ZXN0KTtcbiAgY29uc3QgcmVxdWlyZWRMb29rdXBSZXN1bHQgPSBsb29rdXBSZXN1bHQ7XG4gIGNvbnN0IHRyYW5zZm9ybWVkUmVzcG9uc2UgPSAoKF9lID0gaGFuZGxlUmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVJlcXVlc3RPcHRpb25zLnRyYW5zZm9ybVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FsbChoYW5kbGVSZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UyKSkgfHwgcmVzcG9uc2UyO1xuICAoX2YgPSBoYW5kbGVSZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUmVxdWVzdE9wdGlvbnMub25Nb2NrZWRSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhbGwoXG4gICAgaGFuZGxlUmVxdWVzdE9wdGlvbnMsXG4gICAgdHJhbnNmb3JtZWRSZXNwb25zZSxcbiAgICByZXF1aXJlZExvb2t1cFJlc3VsdFxuICApO1xuICBlbWl0dGVyLmVtaXQoXCJyZXF1ZXN0OmVuZFwiLCByZXF1ZXN0KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkUmVzcG9uc2U7XG59XG5cbi8vIHNyYy9ub2RlL1NldHVwU2VydmVyQXBpLnRzXG52YXIgeyBib2xkIH0gPSBjaGFsaztcbnZhciBERUZBVUxUX0xJU1RFTl9PUFRJT05TID0ge1xuICBvblVuaGFuZGxlZFJlcXVlc3Q6IFwid2FyblwiXG59O1xudmFyIFNldHVwU2VydmVyQXBpID0gY2xhc3MgZXh0ZW5kcyBTZXR1cEFwaSB7XG4gIGNvbnN0cnVjdG9yKGludGVyY2VwdG9ycywgLi4uaGFuZGxlcnMpIHtcbiAgICBzdXBlciguLi5oYW5kbGVycyk7XG4gICAgdGhpcy5pbnRlcmNlcHRvciA9IG5ldyBCYXRjaEludGVyY2VwdG9yKHtcbiAgICAgIG5hbWU6IFwic2V0dXAtc2VydmVyXCIsXG4gICAgICBpbnRlcmNlcHRvcnM6IGludGVyY2VwdG9ycy5tYXAoKEludGVyY2VwdG9yMikgPT4gbmV3IEludGVyY2VwdG9yMigpKVxuICAgIH0pO1xuICAgIHRoaXMucmVzb2x2ZWRPcHRpb25zID0ge307XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmludGVyY2VwdG9yLm9uKFwicmVxdWVzdFwiLCBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3QgbW9ja2VkUmVxdWVzdCA9IG5ldyBNb2NrZWRSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlcXVlc3QuYXJyYXlCdWZmZXIoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBoYW5kbGVSZXF1ZXN0KFxuICAgICAgICBtb2NrZWRSZXF1ZXN0LFxuICAgICAgICB0aGlzLmN1cnJlbnRIYW5kbGVycyxcbiAgICAgICAgdGhpcy5yZXNvbHZlZE9wdGlvbnMsXG4gICAgICAgIHRoaXMuZW1pdHRlcixcbiAgICAgICAge1xuICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlMykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZTMuc3RhdHVzLFxuICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZTMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UzLmhlYWRlcnMuYWxsKCksXG4gICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlMy5ib2R5LFxuICAgICAgICAgICAgICBkZWxheTogcmVzcG9uc2UzLmRlbGF5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZTIpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlMi5kZWxheSkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHJlc3BvbnNlMi5kZWxheSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5yZXNwb25kV2l0aChyZXNwb25zZTIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICAgIHRoaXMuaW50ZXJjZXB0b3Iub24oXCJyZXNwb25zZVwiLCAocmVxdWVzdCwgcmVzcG9uc2UyKSA9PiB7XG4gICAgICBpZiAoIXJlcXVlc3QuaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlMi5oZWFkZXJzLmdldChcIngtcG93ZXJlZC1ieVwiKSA9PT0gXCJtc3dcIikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInJlc3BvbnNlOm1vY2tlZFwiLCByZXNwb25zZTIsIHJlcXVlc3QuaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJyZXNwb25zZTpieXBhc3NcIiwgcmVzcG9uc2UyLCByZXF1ZXN0LmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsaXN0ZW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5yZXNvbHZlZE9wdGlvbnMgPSBtZXJnZVJpZ2h0KFxuICAgICAgREVGQVVMVF9MSVNURU5fT1BUSU9OUyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMuaW50ZXJjZXB0b3IuYXBwbHkoKTtcbiAgICBpbnZhcmlhbnQzKFxuICAgICAgW0ludGVyY2VwdG9yUmVhZHlTdGF0ZS5BUFBMWUlORywgSW50ZXJjZXB0b3JSZWFkeVN0YXRlLkFQUExJRURdLmluY2x1ZGVzKFxuICAgICAgICB0aGlzLmludGVyY2VwdG9yLnJlYWR5U3RhdGVcbiAgICAgICksXG4gICAgICBkZXZVdGlscy5mb3JtYXRNZXNzYWdlKFxuICAgICAgICAnRmFpbGVkIHRvIHN0YXJ0IFwic2V0dXBTZXJ2ZXJcIjogdGhlIGludGVyY2VwdG9yIGZhaWxlZCB0byBhcHBseS4gVGhpcyBpcyBsaWtlbHkgYW4gaXNzdWUgd2l0aCB0aGUgbGlicmFyeSBhbmQgeW91IHNob3VsZCByZXBvcnQgaXQgYXQgXCIlc1wiLidcbiAgICAgICksXG4gICAgICBcImh0dHBzOi8vZ2l0aHViLmNvbS9tc3dqcy9tc3cvaXNzdWVzL25ldy9jaG9vc2VcIlxuICAgICk7XG4gIH1cbiAgcHJpbnRIYW5kbGVycygpIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMubGlzdEhhbmRsZXJzKCk7XG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgY29uc3QgeyBoZWFkZXIsIGNhbGxGcmFtZSB9ID0gaGFuZGxlci5pbmZvO1xuICAgICAgY29uc3QgcHJhZ21hID0gaGFuZGxlci5pbmZvLmhhc093blByb3BlcnR5KFwib3BlcmF0aW9uVHlwZVwiKSA/IFwiW2dyYXBocWxdXCIgOiBcIltyZXN0XVwiO1xuICAgICAgY29uc29sZS5sb2coYCR7Ym9sZChgJHtwcmFnbWF9ICR7aGVhZGVyfWApfVxuICBEZWNsYXJhdGlvbjogJHtjYWxsRnJhbWV9XG5gKTtcbiAgICB9KTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5pbnRlcmNlcHRvci5kaXNwb3NlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ub2RlL3NldHVwU2VydmVyLnRzXG5pbXBvcnQgeyBDbGllbnRSZXF1ZXN0SW50ZXJjZXB0b3IgfSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL0NsaWVudFJlcXVlc3QvaW5kZXguanNcIjtcbmltcG9ydCB7IFhNTEh0dHBSZXF1ZXN0SW50ZXJjZXB0b3IgfSBmcm9tIFwiQG1zd2pzL2ludGVyY2VwdG9ycy9saWIvaW50ZXJjZXB0b3JzL1hNTEh0dHBSZXF1ZXN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBGZXRjaEludGVyY2VwdG9yIH0gZnJvbSBcIkBtc3dqcy9pbnRlcmNlcHRvcnMvbGliL2ludGVyY2VwdG9ycy9mZXRjaC9pbmRleC5qc1wiO1xudmFyIHNldHVwU2VydmVyID0gKC4uLmhhbmRsZXJzKSA9PiB7XG4gIHJldHVybiBuZXcgU2V0dXBTZXJ2ZXJBcGkoXG4gICAgW0NsaWVudFJlcXVlc3RJbnRlcmNlcHRvciwgWE1MSHR0cFJlcXVlc3RJbnRlcmNlcHRvciwgRmV0Y2hJbnRlcmNlcHRvcl0sXG4gICAgLi4uaGFuZGxlcnNcbiAgKTtcbn07XG5leHBvcnQge1xuICBTZXR1cFNlcnZlckFwaSxcbiAgc2V0dXBTZXJ2ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/msw/lib/node/index.mjs\n',
      );

      /***/
    },
};
